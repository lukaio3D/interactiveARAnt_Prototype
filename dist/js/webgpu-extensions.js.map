{"version":3,"file":"js/webgpu-extensions.js","mappings":"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BACA,oCACH,CAHD,CAAkBA,IAAAA,EAAe,KAMjC,SAAkBC,GACd,wCACA,+CACA,gDACA,oDACA,oDACA,mCACA,kDACA,yBACA,qDACA,yCACA,wCACH,CAZD,CAAkBA,IAAAA,EAAW,KAe7B,SAAkBC,GACd,sBACA,oBACA,iBACH,CAJD,CAAkBA,IAAAA,EAAc,KAOhC,SAAYC,GACR,yBACA,2BACA,yBACA,yBACA,sBACA,wBACA,0BACA,2BACA,6BACA,oCACH,CAXD,CAAYA,IAAAA,EAAW,KAcvB,SAAkBC,GACd,mBACA,oBACH,CAHD,CAAkBA,IAAAA,EAAO,KAMzB,SAAkBC,GACd,WACA,WACA,UACH,CAJD,CAAkBA,IAAAA,EAAgB,KAOlC,SAAkBC,GACd,yBACA,yBACA,uCACA,uCACA,2CACH,CAND,CAAkBA,IAAAA,EAAY,KAS9B,SAAkBC,GACd,WACA,WACA,sBACA,cACA,yBACA,UACH,CAPD,CAAkBA,IAAAA,EAAoB,KAUtC,SAAkBC,GACd,YACA,6BACA,wBACH,CAJD,CAAkBA,IAAAA,EAAa,KAU/B,SAAkBC,GAEd,oBACA,oBACA,kBACA,kBAGA,oBACA,oBACA,sBACA,sBACA,sBACA,oBACA,oBAGA,oBACA,oBACA,sBACA,sBACA,sBACA,wBACA,0BACA,mCACA,0BACA,wBACA,wBACA,0BACA,mCAEA,8BACA,4BACA,8BACA,gCAGA,sBACA,sBACA,wBACA,0BACA,0BACA,4BAGA,0BACA,0BACA,4BAGA,sBACA,8BACA,4BACA,6CACA,8BAIA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,0BACA,0BACA,4BACA,4BACA,kCACA,gCACA,gCACA,yCAIA,iCACA,0CACA,qCACA,8CACA,mCACA,4CACA,6BACA,6BACA,+BACA,+BAIA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,kCACA,2CACA,kCACA,2CACA,kCACA,2CACA,oCACA,6CACA,oCACA,6CACA,oCACA,6CAGA,8CACH,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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.alpha.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputeContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputePipelineContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.computeShader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.cubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.debugging.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.dynamicTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.multiRender.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.rawTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.query.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.readTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuRenderTargetWrapper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.renderTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetCube.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.videoTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/WebGPU/webgpuDataBuffer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuBufferManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuBundleList.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuCacheBindGroups.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuCacheRenderPipeline.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuCacheRenderPipelineTree.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuCacheSampler.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuClearQuad.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuConstants.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuDepthCullingState.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuDrawContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuExternalTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuHardwareTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuMaterialContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuOcclusionQuery.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuPerfCounter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuPipelineContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuQuerySet.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuShaderProcessingContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuShaderProcessor.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuSnapshotRendering.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuStencilStateComposer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuTextureHelper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuTextureManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuTimestampQuery.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuTintWASM.ts"],"sourcesContent":["import { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.alpha\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets the current alpha mode\r\n         * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n         */\r\n        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.setAlphaMode = function (mode: number, noDepthWriteChange: boolean = false): void {\r\n    if (this._alphaMode === mode && ((mode === Constants.ALPHA_DISABLE && !this._alphaState.alphaBlend) || (mode !== Constants.ALPHA_DISABLE && this._alphaState.alphaBlend))) {\r\n        if (!noDepthWriteChange) {\r\n            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)\r\n            const depthMask = mode === Constants.ALPHA_DISABLE;\r\n            if (this.depthCullingState.depthMask !== depthMask) {\r\n                this.setDepthWrite(depthMask);\r\n                this._cacheRenderPipeline.setDepthWriteEnabled(depthMask);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    switch (mode) {\r\n        case Constants.ALPHA_DISABLE:\r\n            this._alphaState.alphaBlend = false;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED_PORTERDUFF:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_COMBINE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ADD:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, 1, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SUBTRACT:\r\n            this._alphaState.setAlphaBlendFunctionParameters(0, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MULTIPLY:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_DST_COLOR, 0, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MAXIMIZED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_INTERPOLATE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SCREENMODE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ALPHATOCOLOR:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_DST_ALPHA, 1, 0, 0);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_REVERSEONEMINUS:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEZERO:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 0);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_EXCLUSION:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_LAYER_ACCUMULATE:\r\n            // Same as ALPHA_COMBINE but accumulates (1 - alpha) values in the alpha channel for a later readout in order independant transparency\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_SRC_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA,\r\n                1,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n    }\r\n    if (!noDepthWriteChange) {\r\n        this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(mode === Constants.ALPHA_DISABLE);\r\n    }\r\n    this._alphaMode = mode;\r\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n\r\nWebGPUEngine.prototype.setAlphaEquation = function (equation: number): void {\r\n    AbstractEngine.prototype.setAlphaEquation.call(this, equation);\r\n\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n","import type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.ExternalTexture: {\r\n                        const texture = object as ExternalTexture;\r\n                        const externalTexture = texture.underlyingResource;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._device.importExternalTexture({ source: externalTexture }),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer:\r\n                    case ComputeBindingType.DataBuffer: {\r\n                        const dataBuffer =\r\n                            type === ComputeBindingType.DataBuffer\r\n                                ? (object as DataBuffer)\r\n                                : type === ComputeBindingType.UniformBuffer\r\n                                  ? (object as UniformBuffer).getBuffer()!\r\n                                  : (object as StorageBuffer).getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n","import type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputePipelineContext implements IComputePipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public sources: {\r\n        compute: string;\r\n        rawCompute: string;\r\n    };\r\n\r\n    public stage: Nullable<GPUProgrammableStage>;\r\n\r\n    public computePipeline: GPUComputePipeline;\r\n\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.isAsync) {\r\n            // When async mode is implemented, this should return true if the pipeline is ready\r\n            return false;\r\n        }\r\n\r\n        // In synchronous mode, we return false, the readiness being determined by ComputeEffect\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.engine = engine;\r\n    }\r\n\r\n    public _getComputeShaderCode(): string | null {\r\n        return this.sources?.compute;\r\n    }\r\n\r\n    public dispose(): void {}\r\n}\r\n","import { Logger } from \"core/Misc/logger\";\r\nimport type { IComputeEffectCreationOptions, IComputeShaderPath } from \"../../../Compute/computeEffect\";\r\nimport { ComputeEffect } from \"../../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { ComputeBindingList, ComputeBindingMapping, ComputeCompilationMessages } from \"../../Extensions/engine.computeShader\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPUComputeContext } from \"../webgpuComputeContext\";\r\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport type { WebGPUPerfCounter } from \"../webgpuPerfCounter\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\n\r\ndeclare module \"../../webgpuEngine\" {\r\n    export interface WebGPUEngine {\r\n        /** @internal */\r\n        _createComputePipelineStageDescriptor(computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage;\r\n        /** @internal\r\n         * Either all of x,y,z or buffer and offset should be defined.\r\n         */\r\n        _computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x?: number,\r\n            y?: number,\r\n            z?: number,\r\n            buffer?: DataBuffer,\r\n            offset?: number,\r\n            bindingsMapping?: ComputeBindingMapping,\r\n            gpuPerfCounter?: WebGPUPerfCounter\r\n        ): void;\r\n    }\r\n}\r\n\r\nconst computePassDescriptor: GPUComputePassDescriptor = {};\r\n\r\nWebGPUEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return new WebGPUComputeContext(this._device, this._cacheSampler);\r\n};\r\n\r\nWebGPUEngine.prototype.createComputeEffect = function (baseName: string | (IComputeShaderPath & { computeToken?: string }), options: IComputeEffectCreationOptions): ComputeEffect {\r\n    const compute = typeof baseName === \"string\" ? baseName : baseName.computeToken || baseName.computeSource || baseName.computeElement || baseName.compute;\r\n\r\n    const name = compute + \"@\" + options.defines;\r\n    if (this._compiledComputeEffects[name]) {\r\n        const compiledEffect = <ComputeEffect>this._compiledComputeEffects[name];\r\n        if (options.onCompiled && compiledEffect.isReady()) {\r\n            options.onCompiled(compiledEffect);\r\n        }\r\n\r\n        return compiledEffect;\r\n    }\r\n    const effect = new ComputeEffect(baseName, options, this, name);\r\n    this._compiledComputeEffects[name] = effect;\r\n\r\n    return effect;\r\n};\r\n\r\nWebGPUEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    return new WebGPUComputePipelineContext(this);\r\n};\r\n\r\nWebGPUEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y = 1,\r\n    z = 1,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._computeDispatch(effect, context, bindings, x, y, z, undefined, undefined, bindingsMapping, gpuPerfCounter);\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatchIndirect = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    buffer: DataBuffer,\r\n    offset: number = 0,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._computeDispatch(effect, context, bindings, undefined, undefined, undefined, buffer, offset, bindingsMapping, gpuPerfCounter);\r\n};\r\n\r\nWebGPUEngine.prototype._computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x?: number,\r\n    y?: number,\r\n    z?: number,\r\n    buffer?: DataBuffer,\r\n    offset?: number,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._endCurrentRenderPass();\r\n\r\n    const contextPipeline = effect._pipelineContext as WebGPUComputePipelineContext;\r\n    const computeContext = context as WebGPUComputeContext;\r\n\r\n    if (!contextPipeline.computePipeline) {\r\n        contextPipeline.computePipeline = this._device.createComputePipeline({\r\n            layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n            compute: contextPipeline.stage!,\r\n        });\r\n    }\r\n\r\n    if (gpuPerfCounter) {\r\n        this._timestampQuery.startPass(computePassDescriptor, this._timestampIndex);\r\n    }\r\n\r\n    const computePass = this._renderEncoder.beginComputePass(computePassDescriptor);\r\n\r\n    computePass.setPipeline(contextPipeline.computePipeline);\r\n\r\n    const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\r\n    for (let i = 0; i < bindGroups.length; ++i) {\r\n        const bindGroup = bindGroups[i];\r\n        if (!bindGroup) {\r\n            continue;\r\n        }\r\n        computePass.setBindGroup(i, bindGroup);\r\n    }\r\n\r\n    if (buffer !== undefined) {\r\n        computePass.dispatchWorkgroupsIndirect(buffer.underlyingResource, <number>offset);\r\n    } else {\r\n        if (<number>x + <number>y + <number>z > 0) {\r\n            computePass.dispatchWorkgroups(<number>x, <number>y, <number>z);\r\n        }\r\n    }\r\n    computePass.end();\r\n\r\n    if (gpuPerfCounter) {\r\n        this._timestampQuery.endPass(this._timestampIndex, gpuPerfCounter);\r\n        this._timestampIndex += 2;\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.releaseComputeEffects = function () {\r\n    for (const name in this._compiledComputeEffects) {\r\n        const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext() as WebGPUComputePipelineContext;\r\n        this._deleteComputePipelineContext(webGPUPipelineContextCompute);\r\n    }\r\n\r\n    this._compiledComputeEffects = {};\r\n};\r\n\r\nWebGPUEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {\r\n    const webGpuContext = pipelineContext as WebGPUComputePipelineContext;\r\n\r\n    if (this.dbgShowShaderCode) {\r\n        Logger.Log(defines!);\r\n        Logger.Log(computeSourceCode);\r\n    }\r\n\r\n    webGpuContext.sources = {\r\n        compute: computeSourceCode,\r\n        rawCompute: rawComputeSourceCode,\r\n    };\r\n\r\n    webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\r\n};\r\n\r\nWebGPUEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {\r\n    if (this._compiledComputeEffects[effect._key]) {\r\n        delete this._compiledComputeEffects[effect._key];\r\n\r\n        this._deleteComputePipelineContext(effect.getPipelineContext() as WebGPUComputePipelineContext);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._rebuildComputeEffects = function (): void {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        effect._pipelineContext = null;\r\n        effect._wasPreviouslyReady = false;\r\n        effect._prepareEffect();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._executeWhenComputeStateIsCompiled = function (\r\n    pipelineContext: WebGPUComputePipelineContext,\r\n    action: (messages: Nullable<ComputeCompilationMessages>) => void\r\n): void {\r\n    pipelineContext.stage!.module.getCompilationInfo().then((info) => {\r\n        const compilationMessages: ComputeCompilationMessages = {\r\n            numErrors: 0,\r\n            messages: [],\r\n        };\r\n        for (const message of info.messages) {\r\n            if (message.type === \"error\") {\r\n                compilationMessages.numErrors++;\r\n            }\r\n            compilationMessages.messages.push({\r\n                type: message.type,\r\n                text: message.message,\r\n                line: message.lineNum,\r\n                column: message.linePos,\r\n                length: message.length,\r\n                offset: message.offset,\r\n            });\r\n        }\r\n        action(compilationMessages);\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {\r\n    const webgpuPipelineContext = pipelineContext as WebGPUComputePipelineContext;\r\n    if (webgpuPipelineContext) {\r\n        pipelineContext.dispose();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage {\r\n    if (defines) {\r\n        defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n    } else {\r\n        defines = \"\";\r\n    }\r\n    return {\r\n        module: this._device.createShaderModule({\r\n            code: defines + computeShader,\r\n        }),\r\n        entryPoint,\r\n    };\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @param buffer defines the data buffer to load instead of loading the rootUrl\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * Force the mipmap generation for the given render target texture\r\n         * @param texture defines the render target texture to use\r\n         * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n         */\r\n        generateMipMapsForCubemap(texture: InternalTexture, unbind?: boolean): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.isCube = true;\r\n    internalTexture.label = options.label;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\r\n    const gpuTextureWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer,\r\n        buffer\r\n    );\r\n};\r\n\r\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.generateMipMapsForCubemap = function (texture: InternalTexture) {\r\n    if (texture.generateMipMaps) {\r\n        const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n        if (!gpuTexture) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        this._generateMipmaps(texture);\r\n    }\r\n};\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype._debugPushGroup = function (groupName: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        this._renderEncoder.pushDebugGroup(groupName);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.pushDebugGroup(groupName);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"push\", groupName]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugPopGroup = function (targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        this._renderEncoder.popDebugGroup();\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.popDebugGroup();\r\n    } else {\r\n        this._pendingDebugCommands.push([\"pop\", null]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugInsertMarker = function (text: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        this._renderEncoder.insertDebugMarker(text);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.insertDebugMarker(text);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"insert\", text]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugFlushPendingCommands = function (): void {\r\n    for (let i = 0; i < this._pendingDebugCommands.length; ++i) {\r\n        const [name, param] = this._pendingDebugCommands[i];\r\n\r\n        switch (name) {\r\n            case \"push\":\r\n                this._debugPushGroup(param!);\r\n                break;\r\n            case \"pop\":\r\n                this._debugPopGroup();\r\n                break;\r\n            case \"insert\":\r\n                this._debugInsertMarker(param!);\r\n                break;\r\n        }\r\n    }\r\n    this._pendingDebugCommands.length = 0;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { GetExponentOfTwo } from \"../../../Misc/tools.functions\";\r\nimport type { ICanvas } from \"../../../Engines/ICanvas\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    if (width && height) {\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture?: boolean,\r\n    allowGPUOptimization?: boolean\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const width = source.width,\r\n        height = source.height;\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n    }\r\n\r\n    this._textureHelper.updateTexture(source, texture, width, height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, premulAlpha, 0, 0, allowGPUOptimization);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture);\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    this._endCurrentRenderPass();\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube && !texture.is3D) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types: number[] = [];\r\n    let samplingModes: number[] = [];\r\n    let useSRGBBuffers: boolean[] = [];\r\n    let formats: number[] = [];\r\n    let targets: number[] = [];\r\n    let faceIndex: number[] = [];\r\n    let layerIndex: number[] = [];\r\n    let layers: number[] = [];\r\n    let labels: string[] = [];\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (options.formats) {\r\n            formats = options.formats;\r\n        }\r\n        if (options.targetTypes) {\r\n            targets = options.targetTypes;\r\n        }\r\n        if (options.faceIndex) {\r\n            faceIndex = options.faceIndex;\r\n        }\r\n        if (options.layerIndex) {\r\n            layerIndex = options.layerIndex;\r\n        }\r\n        if (options.layerCounts) {\r\n            layers = options.layerCounts;\r\n        }\r\n\r\n        labels = options.labels ?? labels;\r\n    }\r\n\r\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    let depthStencilTexture = null;\r\n    if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\r\n        if (!generateDepthTexture) {\r\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\r\n            // So, we will align with what the WebGL engine does\r\n            if (generateDepthBuffer && generateStencilBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\r\n            } else if (generateDepthBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n            } else {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\r\n            }\r\n        }\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, \"MultipleRenderTargetDepthStencil\");\r\n    }\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        const format = formats[i] || defaultFormat;\r\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        if (target === -1) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        switch (target) {\r\n            case Constants.TEXTURE_CUBE_MAP:\r\n                texture.isCube = true;\r\n                break;\r\n            case Constants.TEXTURE_3D:\r\n                texture.is3D = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n            case Constants.TEXTURE_2D_ARRAY:\r\n                texture.is2DArray = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n        }\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n        texture.label = labels[i];\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures[textureCount] = depthStencilTexture;\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        gpuTextureWrapper?.releaseMSAATexture();\r\n    }\r\n\r\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\r\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples, false, i === count - 1 && lastTextureIsDepthTexture ? 0 : i);\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0,\r\n    useSRGBBuffer: boolean = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._creationFlags = creationFlags;\r\n    texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture._originalFormat = format;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (format === Constants.TEXTUREFORMAT_RGB) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        gpuTextureWrapper._originalFormatIsRGB = true;\r\n    }\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    _format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = gpuTextureWrapper._originalFormatIsRGB;\r\n\r\n    const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[faces[i]];\r\n        if (needConversion) {\r\n            faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?.removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPURenderItemBeginOcclusionQuery, WebGPURenderItemEndOcclusionQuery } from \"../webgpuBundleList\";\r\n\r\nimport type { PerfCounter } from \"../../../Misc/perfCounter\";\r\nimport type { OcclusionQuery } from \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nimport \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nWebGPUEngine.prototype.getGPUFrameTimeCounter = function (): PerfCounter {\r\n    return this._timestampQuery.gpuFrameTimeCounter;\r\n};\r\n\r\nWebGPUEngine.prototype.captureGPUFrameTime = function (value: boolean) {\r\n    this._timestampQuery.enable = value && !!this._caps.timerQuery;\r\n};\r\n\r\nWebGPUEngine.prototype.createQuery = function (): OcclusionQuery {\r\n    return this._occlusionQuery.createQuery();\r\n};\r\n\r\nWebGPUEngine.prototype.deleteQuery = function (query: OcclusionQuery): WebGPUEngine {\r\n    this._occlusionQuery.deleteQuery(query as number);\r\n\r\n    return this;\r\n};\r\n\r\nWebGPUEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    return this._occlusionQuery.isQueryResultAvailable(query as number);\r\n};\r\n\r\nWebGPUEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    return this._occlusionQuery.getQueryResult(query as number);\r\n};\r\n\r\nWebGPUEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    if (this.compatibilityMode) {\r\n        if (this._occlusionQuery.canBeginQuery(query as number)) {\r\n            this._currentRenderPass?.beginOcclusionQuery(query as number);\r\n            return true;\r\n        }\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query as number));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nWebGPUEngine.prototype.endOcclusionQuery = function (): WebGPUEngine {\r\n    if (this.compatibilityMode) {\r\n        this._currentRenderPass?.endOcclusionQuery();\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());\r\n    }\r\n    return this;\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource!, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);\r\n};\r\n\r\nWebGPUEngine.prototype._readTexturePixelsSync = function (): ArrayBufferView {\r\n    // eslint-disable-next-line no-throw-literal\r\n    throw \"_readTexturePixelsSync is unsupported in WebGPU!\";\r\n};\r\n","import type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\n\r\n/**\r\n * Specialized class used to store a render target of a WebGPU engine\r\n */\r\nexport class WebGPURenderTargetWrapper extends RenderTargetWrapper {\r\n    /** @internal */\r\n    public _defaultAttachments: number[];\r\n\r\n    /**\r\n     * Gets the GPU time spent rendering this render target in the last frame (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     */\r\n    public readonly gpuTimeInFrame?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     * @param label defines the label to use for the wrapper (for debugging purpose only)\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: WebGPUEngine, label?: string) {\r\n        super(isMulti, isCube, size, engine, label);\r\n\r\n        if (engine.enableGPUTimingMeasurements) {\r\n            this.gpuTimeInFrame = new WebGPUPerfCounter();\r\n        }\r\n    }\r\n}\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, DepthTextureCreationOptions, TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.texture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target wrapper ready to render texture\r\n         */\r\n        createRenderTargetTexture(size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Updates the sample count of a render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number;\r\n\r\n        /** @internal */\r\n        _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /** @internal */\r\n        _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper;\r\n\r\n        /** @internal */\r\n        _setupDepthStencilTexture(\r\n            internalTexture: InternalTexture,\r\n            size: TextureSize,\r\n            generateStencil: boolean,\r\n            bilinearFiltering: boolean,\r\n            comparisonFunction: number,\r\n            samples?: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti: boolean, isCube: boolean, size: TextureSize): WebGPURenderTargetWrapper {\r\n    const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);\r\n    this._renderTargetWrapperCache.push(rtWrapper);\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.createRenderTargetTexture = function (size: TextureSize, options: boolean | RenderTargetCreationOptions): WebGPURenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        fullOptions.generateMipMaps = options.generateMipMaps;\r\n        fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n        fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        fullOptions.creationFlags = options.creationFlags ?? 0;\r\n        fullOptions.noColorAttachment = !!options.noColorAttachment;\r\n        fullOptions.samples = options.samples;\r\n        fullOptions.label = options.label;\r\n    } else {\r\n        fullOptions.generateMipMaps = <boolean>options;\r\n        fullOptions.generateDepthBuffer = true;\r\n        fullOptions.generateStencilBuffer = false;\r\n        fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        fullOptions.creationFlags = 0;\r\n        fullOptions.noColorAttachment = false;\r\n    }\r\n\r\n    const texture = fullOptions.noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._samples = fullOptions.samples ?? 1;\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            false, // force false as filtering is not supported for depth textures\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples,\r\n            fullOptions.generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n            fullOptions.label ? fullOptions.label + \"-DepthStencil\" : undefined\r\n        );\r\n    }\r\n\r\n    if (texture) {\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);\r\n\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype._createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.label = options.label;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\r\n    const gpuTextureWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype._setupDepthStencilTexture = function (\r\n    internalTexture: InternalTexture,\r\n    size: TextureSize,\r\n    generateStencil: boolean,\r\n    bilinearFiltering: boolean,\r\n    comparisonFunction: number,\r\n    samples = 1\r\n): void {\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n    const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n    const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n\r\n    internalTexture.baseWidth = width;\r\n    internalTexture.baseHeight = height;\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.is2DArray = layers > 0;\r\n    internalTexture.is3D = depth > 0;\r\n    internalTexture.depth = layers || depth;\r\n    internalTexture.isReady = true;\r\n    internalTexture.samples = samples;\r\n    internalTexture.generateMipMaps = false;\r\n    internalTexture.samplingMode = bilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n    internalTexture._comparisonFunction = comparisonFunction;\r\n    internalTexture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    internalTexture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    this._textureHelper.createMSAATexture(rtWrapper.texture, samples);\r\n\r\n    if (rtWrapper._depthStencilTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n    rtWrapper.texture.samples = samples;\r\n\r\n    return samples;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target cube wrapper\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target cube wrapper\r\n         */\r\n        createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createRenderTargetCubeTexture = function (size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\r\n\r\n    const fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.depth = 0;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = fullOptions.samples;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            fullOptions.samplingMode === undefined ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST,\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples\r\n        );\r\n    }\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = true;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = false;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n","import type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a depth stencil texture from a render target to the according uniform.\r\n         * @param channel The texture channel\r\n         * @param uniform The uniform to set\r\n         * @param texture The render target texture containing the depth stencil texture to apply\r\n         * @param name The texture name\r\n         */\r\n        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.setDepthStencilTexture = function (channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void {\r\n    if (!texture || !texture.depthStencilTexture) {\r\n        this._setTexture(channel, null, undefined, undefined, name);\r\n    } else {\r\n        this._setTexture(channel, texture, false, true, name);\r\n    }\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../../Materials/Textures/externalTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nfunction IsExternalTexture(texture: Nullable<ExternalTexture> | HTMLVideoElement): texture is ExternalTexture {\r\n    return texture && (texture as ExternalTexture).underlyingResource !== undefined ? true : false;\r\n}\r\n\r\nWebGPUEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    if (this._videoTextureSupported === undefined) {\r\n        this._videoTextureSupported = true;\r\n    }\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (IsExternalTexture(video)) {\r\n        if (video.isReady()) {\r\n            try {\r\n                this._textureHelper.copyVideoToTexture(video, texture, gpuTextureWrapper.format, !invertY);\r\n                if (texture.generateMipMaps) {\r\n                    this._generateMipmaps(texture);\r\n                }\r\n            } catch (e) {\r\n                // WebGPU doesn't support video element who are not playing so far\r\n                // Ignore this error ensures we can start a video texture in a paused state\r\n            }\r\n            texture.isReady = true;\r\n        }\r\n    } else if (video) {\r\n        this.createImageBitmap(video)\r\n            .then((bitmap) => {\r\n                this._textureHelper.updateTexture(bitmap, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, !invertY, false, 0, 0);\r\n                if (texture.generateMipMaps) {\r\n                    this._generateMipmaps(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n            })\r\n            .catch(() => {\r\n                // Sometimes createImageBitmap(video) fails with \"Failed to execute 'createImageBitmap' on 'Window': The provided element's player has no current data.\"\r\n                // Just keep going on\r\n                texture.isReady = true;\r\n            });\r\n    }\r\n};\r\n","import { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGPUDataBuffer extends DataBuffer {\r\n    private _buffer: Nullable<GPUBuffer>;\r\n\r\n    // Used to make sure the buffer is not recreated twice after a context loss/restoration\r\n    public engineId = -1;\r\n\r\n    public constructor(resource: GPUBuffer, capacity = 0) {\r\n        super();\r\n        this.capacity = capacity;\r\n        this._buffer = resource;\r\n    }\r\n\r\n    public override get underlyingResource(): any {\r\n        return this._buffer;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport { FromHalfFloat } from \"../../Misc/textureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUBufferManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _deferredReleaseBuffers: Array<GPUBuffer> = [];\r\n\r\n    private static _IsGPUBuffer(buffer: DataBuffer | GPUBuffer): buffer is GPUBuffer {\r\n        return (buffer as DataBuffer).underlyingResource === undefined;\r\n    }\r\n\r\n    private static _FlagsToString(flags: GPUBufferUsageFlags, suffix = \"\") {\r\n        let result = suffix;\r\n\r\n        for (let i = 0; i <= 9; ++i) {\r\n            if (flags & (1 << i)) {\r\n                if (result) {\r\n                    result += \"_\";\r\n                }\r\n                result += WebGPUConstants.BufferUsage[1 << i];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n    }\r\n\r\n    public createRawBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, mappedAtCreation = false, label?: string): GPUBuffer {\r\n        const alignedLength = (viewOrSize as ArrayBufferView).byteLength !== undefined ? ((viewOrSize as ArrayBufferView).byteLength + 3) & ~3 : ((viewOrSize as number) + 3) & ~3; // 4 bytes alignments (because of the upload which requires this)\r\n        const verticesBufferDescriptor = {\r\n            label: \"BabylonWebGPUDevice\" + this._engine.uniqueId + \"_\" + WebGPUBufferManager._FlagsToString(flags, label ?? \"Buffer\") + \"_size\" + alignedLength,\r\n            mappedAtCreation,\r\n            size: alignedLength,\r\n            usage: flags,\r\n        };\r\n\r\n        return this._device.createBuffer(verticesBufferDescriptor);\r\n    }\r\n\r\n    public createBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, label?: string): WebGPUDataBuffer {\r\n        const isView = (viewOrSize as ArrayBufferView).byteLength !== undefined;\r\n        const buffer = this.createRawBuffer(viewOrSize, flags, undefined, label);\r\n        const dataBuffer = new WebGPUDataBuffer(buffer);\r\n        dataBuffer.references = 1;\r\n        dataBuffer.capacity = isView ? (viewOrSize as ArrayBufferView).byteLength : (viewOrSize as number);\r\n        dataBuffer.engineId = this._engine.uniqueId;\r\n\r\n        if (isView) {\r\n            this.setSubData(dataBuffer, 0, viewOrSize as ArrayBufferView);\r\n        }\r\n\r\n        return dataBuffer;\r\n    }\r\n\r\n    public setRawData(buffer: GPUBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset: number, byteLength: number): void {\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\r\n    }\r\n\r\n    public setSubData(dataBuffer: WebGPUDataBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset = 0, byteLength = 0): void {\r\n        const buffer = dataBuffer.underlyingResource as GPUBuffer;\r\n\r\n        byteLength = byteLength || src.byteLength;\r\n        byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);\r\n\r\n        // After Migration to Canary\r\n        let chunkStart = src.byteOffset + srcByteOffset;\r\n        let chunkEnd = chunkStart + byteLength;\r\n\r\n        // 4 bytes alignments for upload\r\n        const alignedLength = (byteLength + 3) & ~3;\r\n        if (alignedLength !== byteLength) {\r\n            const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\r\n            src = new Uint8Array(alignedLength);\r\n            (src as Uint8Array).set(tempView);\r\n            srcByteOffset = 0;\r\n            chunkStart = 0;\r\n            chunkEnd = alignedLength;\r\n            byteLength = alignedLength;\r\n        }\r\n\r\n        // Chunk\r\n        const maxChunk = 1024 * 1024 * 15;\r\n        let offset = 0;\r\n        while (chunkEnd - (chunkStart + offset) > maxChunk) {\r\n            this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\r\n            offset += maxChunk;\r\n        }\r\n\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\r\n    }\r\n\r\n    private _getHalfFloatAsFloatRGBAArrayBuffer(dataLength: number, arrayBuffer: ArrayBuffer, destArray?: Float32Array): Float32Array {\r\n        if (!destArray) {\r\n            destArray = new Float32Array(dataLength);\r\n        }\r\n        const srcData = new Uint16Array(arrayBuffer);\r\n        while (dataLength--) {\r\n            destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    public readDataFromBuffer(\r\n        gpuBuffer: GPUBuffer,\r\n        size: number,\r\n        width: number,\r\n        height: number,\r\n        bytesPerRow: number,\r\n        bytesPerRowAligned: number,\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        offset = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        destroyBuffer = true,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const floatFormat = type === Constants.TEXTURETYPE_FLOAT ? 2 : type === Constants.TEXTURETYPE_HALF_FLOAT ? 1 : 0;\r\n        const engineId = this._engine.uniqueId;\r\n        return new Promise((resolve, reject) => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\r\n                    let data: Nullable<ArrayBufferView> | Uint8Array | Float32Array = buffer;\r\n                    if (noDataConversion) {\r\n                        if (data === null) {\r\n                            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\r\n                        } else {\r\n                            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\r\n                        }\r\n                    } else {\r\n                        if (data === null) {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(size);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(size / 4);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        } else {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(data.buffer);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer as Float32Array);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(data.buffer);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bytesPerRow !== bytesPerRowAligned) {\r\n                        // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\r\n                        if (floatFormat === 1 && !noDataConversion) {\r\n                            // half float have been converted to float above\r\n                            bytesPerRow *= 2;\r\n                            bytesPerRowAligned *= 2;\r\n                        }\r\n                        const data2 = new Uint8Array(data!.buffer);\r\n                        let offset = bytesPerRow,\r\n                            offset2 = 0;\r\n                        for (let y = 1; y < height; ++y) {\r\n                            offset2 = y * bytesPerRowAligned;\r\n                            for (let x = 0; x < bytesPerRow; ++x) {\r\n                                data2[offset++] = data2[offset2++];\r\n                            }\r\n                        }\r\n                        if (floatFormat !== 0 && !noDataConversion) {\r\n                            data = new Float32Array(data2.buffer, 0, offset / 4);\r\n                        } else {\r\n                            data = new Uint8Array(data2.buffer, 0, offset);\r\n                        }\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    if (destroyBuffer) {\r\n                        this.releaseBuffer(gpuBuffer);\r\n                    }\r\n                    resolve(data!);\r\n                },\r\n                (reason) => {\r\n                    if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                        // The engine was disposed while waiting for the promise, or a context loss/restoration has occurred: don't reject\r\n                        resolve(new Uint8Array());\r\n                    } else {\r\n                        reject(reason);\r\n                    }\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    public releaseBuffer(buffer: DataBuffer | GPUBuffer): boolean {\r\n        if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\r\n            this._deferredReleaseBuffers.push(buffer);\r\n            return true;\r\n        }\r\n\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deferredReleaseBuffers.push(buffer.underlyingResource as GPUBuffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public destroyDeferredBuffers(): void {\r\n        for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\r\n            this._deferredReleaseBuffers[i].destroy();\r\n        }\r\n\r\n        this._deferredReleaseBuffers.length = 0;\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\n/** @internal */\r\ninterface IWebGPURenderItem {\r\n    run(renderPass: GPURenderPassEncoder): void;\r\n    clone(): IWebGPURenderItem;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemViewport implements IWebGPURenderItem {\r\n    public x: number;\r\n    public y: number;\r\n    public w: number;\r\n    public h: number;\r\n\r\n    public constructor(x: number, y: number, w: number, h: number) {\r\n        this.x = Math.floor(x);\r\n        this.y = Math.floor(y);\r\n        this.w = Math.floor(w);\r\n        this.h = Math.floor(h);\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemViewport {\r\n        return new WebGPURenderItemViewport(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemScissor implements IWebGPURenderItem {\r\n    public constructor(\r\n        public x: number,\r\n        public y: number,\r\n        public w: number,\r\n        public h: number\r\n    ) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setScissorRect(this.x, this.y, this.w, this.h);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemScissor {\r\n        return new WebGPURenderItemScissor(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemStencilRef implements IWebGPURenderItem {\r\n    public constructor(public ref: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setStencilReference(this.ref);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemStencilRef {\r\n        return new WebGPURenderItemStencilRef(this.ref);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBlendColor implements IWebGPURenderItem {\r\n    public constructor(public color: Nullable<number>[]) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setBlendConstant(this.color as GPUColor);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBlendColor {\r\n        return new WebGPURenderItemBlendColor(this.color);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBeginOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor(public query: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.beginOcclusionQuery(this.query);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBeginOcclusionQuery {\r\n        return new WebGPURenderItemBeginOcclusionQuery(this.query);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemEndOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor() {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.endOcclusionQuery();\r\n    }\r\n\r\n    public clone(): WebGPURenderItemEndOcclusionQuery {\r\n        return new WebGPURenderItemEndOcclusionQuery();\r\n    }\r\n}\r\n\r\nclass WebGPURenderItemBundles implements IWebGPURenderItem {\r\n    public bundles: GPURenderBundle[];\r\n\r\n    public constructor() {\r\n        this.bundles = [];\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.executeBundles(this.bundles);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBundles {\r\n        const cloned = new WebGPURenderItemBundles();\r\n        cloned.bundles = this.bundles;\r\n        return cloned;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUBundleList {\r\n    private _device: GPUDevice;\r\n    private _bundleEncoder: GPURenderBundleEncoder | undefined;\r\n\r\n    private _list: IWebGPURenderItem[];\r\n    private _listLength: number;\r\n\r\n    private _currentItemIsBundle: boolean;\r\n    private _currentBundleList: GPURenderBundle[];\r\n\r\n    public numDrawCalls = 0;\r\n\r\n    public constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this._list = new Array(10);\r\n        this._listLength = 0;\r\n    }\r\n\r\n    public addBundle(bundle?: GPURenderBundle): void {\r\n        if (!this._currentItemIsBundle) {\r\n            const item = new WebGPURenderItemBundles();\r\n\r\n            this._list[this._listLength++] = item;\r\n            this._currentBundleList = item.bundles;\r\n            this._currentItemIsBundle = true;\r\n        }\r\n        if (bundle) {\r\n            this._currentBundleList.push(bundle);\r\n        }\r\n    }\r\n\r\n    private _finishBundle(): void {\r\n        if (this._currentItemIsBundle && this._bundleEncoder) {\r\n            this._currentBundleList.push(this._bundleEncoder.finish());\r\n            this._bundleEncoder = undefined;\r\n            this._currentItemIsBundle = false;\r\n        }\r\n    }\r\n\r\n    public addItem(item: IWebGPURenderItem) {\r\n        this._finishBundle();\r\n        this._list[this._listLength++] = item;\r\n        this._currentItemIsBundle = false;\r\n    }\r\n\r\n    public getBundleEncoder(colorFormats: (GPUTextureFormat | null)[], depthStencilFormat: GPUTextureFormat | undefined, sampleCount: number): GPURenderBundleEncoder {\r\n        if (!this._currentItemIsBundle) {\r\n            this.addBundle();\r\n            this._bundleEncoder = this._device.createRenderBundleEncoder({\r\n                colorFormats,\r\n                depthStencilFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n        return this._bundleEncoder!;\r\n    }\r\n\r\n    public close(): void {\r\n        this._finishBundle();\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        this.close();\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            this._list[i].run(renderPass);\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this._listLength = 0;\r\n        this._currentItemIsBundle = false;\r\n        this.numDrawCalls = 0;\r\n    }\r\n\r\n    public clone(): WebGPUBundleList {\r\n        this.close();\r\n\r\n        const cloned = new WebGPUBundleList(this._device);\r\n\r\n        cloned._list = new Array(this._listLength);\r\n        cloned._listLength = this._listLength;\r\n        cloned.numDrawCalls = this.numDrawCalls;\r\n\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            cloned._list[i] = this._list[i].clone();\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     * @returns a bind group array\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = drawContext.buffers[bufferName]?.uniqueId ?? 0;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = materialContext.textures[textureName]?.texture?.uniqueId ?? 0;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode, sampler.label);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key: string, value: any) =>\r\n                                    key === \"texture\" ? \"<no dump>\" : value\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Constants } from \"../constants\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\nimport { checkNonFloatVertexBuffers } from \"core/Buffers/buffer.nonFloatVertexBuffers\";\r\n\r\nenum StatePosition {\r\n    StencilReadMask = 0,\r\n    StencilWriteMask = 1,\r\n    //DepthBiasClamp = 1, // not used, so remove it to improve perf\r\n    DepthBias = 2,\r\n    DepthBiasSlopeScale = 3,\r\n    DepthStencilState = 4,\r\n    MRTAttachments1 = 5,\r\n    MRTAttachments2 = 6,\r\n    RasterizationState = 7,\r\n    ColorStates = 8,\r\n    ShaderStage = 9,\r\n    TextureStage = 10,\r\n    VertexState = 11, // vertex state will consume positions 11, 12, ... depending on the number of vertex inputs\r\n\r\n    NumStates = 12,\r\n}\r\n\r\nconst alphaBlendFactorToIndex: { [name: number]: number } = {\r\n    0: 1, // Zero\r\n    1: 2, // One\r\n    0x0300: 3, // SrcColor\r\n    0x0301: 4, // OneMinusSrcColor\r\n    0x0302: 5, // SrcAlpha\r\n    0x0303: 6, // OneMinusSrcAlpha\r\n    0x0304: 7, // DstAlpha\r\n    0x0305: 8, // OneMinusDstAlpha\r\n    0x0306: 9, // DstColor\r\n    0x0307: 10, // OneMinusDstColor\r\n    0x0308: 11, // SrcAlphaSaturated\r\n    0x8001: 12, // BlendColor\r\n    0x8002: 13, // OneMinusBlendColor\r\n    0x8003: 12, // BlendColor (alpha)\r\n    0x8004: 13, // OneMinusBlendColor (alpha)\r\n};\r\n\r\nconst stencilOpToIndex: { [name: number]: number } = {\r\n    0x0000: 0, // ZERO\r\n    0x1e00: 1, // KEEP\r\n    0x1e01: 2, // REPLACE\r\n    0x1e02: 3, // INCR\r\n    0x1e03: 4, // DECR\r\n    0x150a: 5, // INVERT\r\n    0x8507: 6, // INCR_WRAP\r\n    0x8508: 7, // DECR_WRAP\r\n};\r\n\r\n/** @internal */\r\nexport abstract class WebGPUCacheRenderPipeline {\r\n    public static NumCacheHitWithoutHash = 0;\r\n    public static NumCacheHitWithHash = 0;\r\n    public static NumCacheMiss = 0;\r\n    public static NumPipelineCreationLastFrame = 0;\r\n\r\n    public disabled: boolean;\r\n\r\n    private static _NumPipelineCreationCurrentFrame = 0;\r\n\r\n    protected _states: number[];\r\n    protected _statesLength: number;\r\n    protected _stateDirtyLowestIndex: number;\r\n    public lastStateDirtyLowestIndex: number; // for stats only\r\n\r\n    private _device: GPUDevice;\r\n    private _isDirty: boolean;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    private _parameter: { token: any; pipeline: Nullable<GPURenderPipeline> };\r\n    private _kMaxVertexBufferStride;\r\n\r\n    private _shaderId: number;\r\n    private _alphaToCoverageEnabled: boolean;\r\n    private _frontFace: number;\r\n    private _cullEnabled: boolean;\r\n    private _cullFace: number;\r\n    private _clampDepth: boolean;\r\n    private _rasterizationState: number;\r\n    private _depthBias: number;\r\n    private _depthBiasClamp: number;\r\n    private _depthBiasSlopeScale: number;\r\n    private _colorFormat: number;\r\n    private _webgpuColorFormat: (GPUTextureFormat | null)[];\r\n    private _mrtAttachments1: number;\r\n    private _mrtAttachments2: number;\r\n    private _mrtFormats: (GPUTextureFormat | null)[];\r\n    private _mrtEnabledMask: number;\r\n    private _alphaBlendEnabled: boolean;\r\n    private _alphaBlendFuncParams: Array<Nullable<number>>;\r\n    private _alphaBlendEqParams: Array<Nullable<number>>;\r\n    private _writeMask: number;\r\n    private _colorStates: number;\r\n    private _depthStencilFormat: number;\r\n    private _webgpuDepthStencilFormat: GPUTextureFormat | undefined;\r\n    private _depthTestEnabled: boolean;\r\n    private _depthWriteEnabled: boolean;\r\n    private _depthCompare: number;\r\n    private _stencilEnabled: boolean;\r\n    private _stencilFrontCompare: number;\r\n    private _stencilFrontDepthFailOp: number;\r\n    private _stencilFrontPassOp: number;\r\n    private _stencilFrontFailOp: number;\r\n    private _stencilReadMask: number;\r\n    private _stencilWriteMask: number;\r\n    private _depthStencilState: number;\r\n    private _vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _textureState: number;\r\n    private _useTextureStage: boolean;\r\n\r\n    constructor(device: GPUDevice, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._useTextureStage = true; // we force usage because we must handle depth textures with \"float\" filtering, which can't be fixed by a caps (like \"textureFloatLinearFiltering\" can for float textures)\r\n        this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\r\n        this._statesLength = 0;\r\n        this._stateDirtyLowestIndex = 0;\r\n        this._emptyVertexBuffer = emptyVertexBuffer;\r\n        this._mrtFormats = [];\r\n        this._parameter = { token: undefined, pipeline: null };\r\n        this.disabled = false;\r\n        this.vertexBuffers = [];\r\n        this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this._isDirty = true;\r\n        this.vertexBuffers.length = 0;\r\n        this.setAlphaToCoverage(false);\r\n        this.resetDepthCullingState();\r\n        this.setClampDepth(false);\r\n        this.setDepthBias(0);\r\n        //this.setDepthBiasClamp(0);\r\n        this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\r\n        this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\r\n        this.setMRT([]);\r\n        this.setAlphaBlendEnabled(false);\r\n        this.setAlphaBlendFactors([null, null, null, null], [null, null]);\r\n        this.setWriteMask(0xf);\r\n        this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\r\n        this.setStencilEnabled(false);\r\n        this.resetStencilState();\r\n        this.setBuffers(null, null, null);\r\n        this._setTextureState(0);\r\n    }\r\n\r\n    protected abstract _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n    protected abstract _setRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n\r\n    public readonly vertexBuffers: VertexBuffer[];\r\n\r\n    public get colorFormats(): (GPUTextureFormat | null)[] {\r\n        return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;\r\n    }\r\n\r\n    public readonly mrtAttachments: number[];\r\n    public readonly mrtTextureArray: InternalTexture[];\r\n    public readonly mrtTextureCount: number = 0;\r\n\r\n    public getRenderPipeline(fillMode: number, effect: Effect, sampleCount: number, textureState = 0): GPURenderPipeline {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        if (this.disabled) {\r\n            const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n            this._setVertexState(effect); // to fill this.vertexBuffers with correct data\r\n            this._setTextureState(textureState);\r\n\r\n            this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n\r\n            WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n            WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._setShaderStage(effect.uniqueId);\r\n        this._setRasterizationState(fillMode, sampleCount);\r\n        this._setColorStates();\r\n        this._setDepthStencilState();\r\n        this._setVertexState(effect);\r\n        this._setTextureState(textureState);\r\n\r\n        this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\r\n\r\n        if (!this._isDirty && this._parameter.pipeline) {\r\n            this._stateDirtyLowestIndex = this._statesLength;\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._getRenderPipeline(this._parameter);\r\n\r\n        this._isDirty = false;\r\n        this._stateDirtyLowestIndex = this._statesLength;\r\n\r\n        if (this._parameter.pipeline) {\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n        this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n        this._setRenderPipeline(this._parameter);\r\n\r\n        WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n        return this._parameter.pipeline;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\r\n    }\r\n\r\n    public setAlphaToCoverage(enabled: boolean): void {\r\n        this._alphaToCoverageEnabled = enabled;\r\n    }\r\n\r\n    public setFrontFace(frontFace: number): void {\r\n        this._frontFace = frontFace;\r\n    }\r\n\r\n    public setCullEnabled(enabled: boolean): void {\r\n        this._cullEnabled = enabled;\r\n    }\r\n\r\n    public setCullFace(cullFace: number): void {\r\n        this._cullFace = cullFace;\r\n    }\r\n\r\n    public setClampDepth(clampDepth: boolean): void {\r\n        this._clampDepth = clampDepth;\r\n    }\r\n\r\n    public resetDepthCullingState(): void {\r\n        this.setDepthCullingState(false, 2, 1, 0, 0, true, true, Constants.ALWAYS);\r\n    }\r\n\r\n    public setDepthCullingState(\r\n        cullEnabled: boolean,\r\n        frontFace: number,\r\n        cullFace: number,\r\n        zOffset: number,\r\n        zOffsetUnits: number,\r\n        depthTestEnabled: boolean,\r\n        depthWriteEnabled: boolean,\r\n        depthCompare: Nullable<number>\r\n    ): void {\r\n        this._depthWriteEnabled = depthWriteEnabled;\r\n        this._depthTestEnabled = depthTestEnabled;\r\n        this._depthCompare = (depthCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._cullFace = cullFace;\r\n        this._cullEnabled = cullEnabled;\r\n        this._frontFace = frontFace;\r\n        this.setDepthBiasSlopeScale(zOffset);\r\n        this.setDepthBias(zOffsetUnits);\r\n    }\r\n\r\n    public setDepthBias(depthBias: number): void {\r\n        if (this._depthBias !== depthBias) {\r\n            this._depthBias = depthBias;\r\n            this._states[StatePosition.DepthBias] = depthBias;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\r\n        }\r\n    }\r\n\r\n    /*public setDepthBiasClamp(depthBiasClamp: number): void {\r\n        if (this._depthBiasClamp !== depthBiasClamp) {\r\n            this._depthBiasClamp = depthBiasClamp;\r\n            this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\r\n            this._isDirty = true;\r\n        }\r\n    }*/\r\n\r\n    public setDepthBiasSlopeScale(depthBiasSlopeScale: number): void {\r\n        if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\r\n            this._depthBiasSlopeScale = depthBiasSlopeScale;\r\n            this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\r\n        }\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._webgpuColorFormat[0] = format;\r\n        this._colorFormat = renderableTextureFormatToIndex[format ?? \"\"];\r\n    }\r\n\r\n    public setMRTAttachments(attachments: number[]): void {\r\n        (this.mrtAttachments as any) = attachments;\r\n        let mask = 0;\r\n        for (let i = 0; i < attachments.length; ++i) {\r\n            if (attachments[i] !== 0) {\r\n                mask += 1 << i;\r\n            }\r\n        }\r\n        if (this._mrtEnabledMask !== mask) {\r\n            this._mrtEnabledMask = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\r\n        }\r\n    }\r\n\r\n    public setMRT(textureArray: InternalTexture[], textureCount?: number): void {\r\n        textureCount = textureCount ?? textureArray.length;\r\n        if (textureCount > 10) {\r\n            // If we want more than 10 attachments we need to change this method (and the StatePosition enum) but 10 seems plenty: note that WebGPU only supports 8 at the time (2021/12/13)!\r\n            // As we need ~39 different values we are using 6 bits to encode a texture format, meaning we can encode 5 texture formats in 32 bits\r\n            // We are using 2x32 bit values to handle 10 textures\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Can't handle more than 10 attachments for a MRT in cache render pipeline!\";\r\n        }\r\n        (this.mrtTextureArray as any) = textureArray;\r\n        (this.mrtTextureCount as any) = textureCount;\r\n\r\n        this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\r\n\r\n        const bits: number[] = [0, 0];\r\n        let indexBits = 0,\r\n            mask = 0,\r\n            numRT = 0;\r\n        for (let i = 0; i < textureCount; ++i) {\r\n            const texture = textureArray[i];\r\n            const gpuWrapper = texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n            this._mrtFormats[numRT] = gpuWrapper?.format ?? this._webgpuColorFormat[0];\r\n\r\n            bits[indexBits] += renderableTextureFormatToIndex[this._mrtFormats[numRT] ?? \"\"] << mask;\r\n            mask += 6;\r\n            numRT++;\r\n\r\n            if (mask >= 32) {\r\n                mask = 0;\r\n                indexBits++;\r\n            }\r\n        }\r\n        this._mrtFormats.length = numRT;\r\n        if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {\r\n            this._mrtAttachments1 = bits[0];\r\n            this._mrtAttachments2 = bits[1];\r\n            this._states[StatePosition.MRTAttachments1] = bits[0];\r\n            this._states[StatePosition.MRTAttachments2] = bits[1];\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\r\n        }\r\n    }\r\n\r\n    public setAlphaBlendEnabled(enabled: boolean): void {\r\n        this._alphaBlendEnabled = enabled;\r\n    }\r\n\r\n    public setAlphaBlendFactors(factors: Array<Nullable<number>>, operations: Array<Nullable<number>>): void {\r\n        this._alphaBlendFuncParams = factors;\r\n        this._alphaBlendEqParams = operations;\r\n    }\r\n\r\n    public setWriteMask(mask: number): void {\r\n        this._writeMask = mask;\r\n    }\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._webgpuDepthStencilFormat = format;\r\n        this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\r\n    }\r\n\r\n    public setDepthTestEnabled(enabled: boolean): void {\r\n        this._depthTestEnabled = enabled;\r\n    }\r\n\r\n    public setDepthWriteEnabled(enabled: boolean): void {\r\n        this._depthWriteEnabled = enabled;\r\n    }\r\n\r\n    public setDepthCompare(func: Nullable<number>): void {\r\n        this._depthCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilEnabled(enabled: boolean): void {\r\n        this._stencilEnabled = enabled;\r\n    }\r\n\r\n    public setStencilCompare(func: Nullable<number>): void {\r\n        this._stencilFrontCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilPassOp(op: Nullable<number>): void {\r\n        this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilReadMask(mask: number): void {\r\n        if (this._stencilReadMask !== mask) {\r\n            this._stencilReadMask = mask;\r\n            this._states[StatePosition.StencilReadMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\r\n        }\r\n    }\r\n\r\n    public setStencilWriteMask(mask: number): void {\r\n        if (this._stencilWriteMask !== mask) {\r\n            this._stencilWriteMask = mask;\r\n            this._states[StatePosition.StencilWriteMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\r\n        }\r\n    }\r\n\r\n    public resetStencilState(): void {\r\n        this.setStencilState(false, Constants.ALWAYS, Constants.KEEP, Constants.REPLACE, Constants.KEEP, 0xff, 0xff);\r\n    }\r\n\r\n    public setStencilState(\r\n        stencilEnabled: boolean,\r\n        compare: Nullable<number>,\r\n        depthFailOp: Nullable<number>,\r\n        passOp: Nullable<number>,\r\n        failOp: Nullable<number>,\r\n        readMask: number,\r\n        writeMask: number\r\n    ): void {\r\n        this._stencilEnabled = stencilEnabled;\r\n        this._stencilFrontCompare = (compare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\r\n        this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\r\n        this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\r\n        this.setStencilReadMask(readMask);\r\n        this.setStencilWriteMask(writeMask);\r\n    }\r\n\r\n    public setBuffers(\r\n        vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>,\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        this._vertexBuffers = vertexBuffers;\r\n        this._overrideVertexBuffers = overrideVertexBuffers;\r\n        this._indexBuffer = indexBuffer;\r\n    }\r\n\r\n    private static _GetTopology(fillMode: number): GPUPrimitiveTopology {\r\n        switch (fillMode) {\r\n            // Triangle views\r\n            case Constants.MATERIAL_TriangleFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n            case Constants.MATERIAL_PointFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_WireFrameFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            // Draw modes\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_LineListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n                // return this._gl.LINE_LOOP;\r\n                // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"LineLoop is an unsupported fillmode in WebGPU\";\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineStrip;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                // return this._gl.TRIANGLE_FAN;\r\n                // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TriangleFan is an unsupported fillmode in WebGPU\";\r\n            default:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendOperation(operation: Nullable<number>): GPUBlendOperation {\r\n        switch (operation) {\r\n            case Constants.GL_ALPHA_EQUATION_ADD:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n            case Constants.GL_ALPHA_EQUATION_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.Subtract;\r\n            case Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.ReverseSubtract;\r\n            case Constants.GL_ALPHA_EQUATION_MIN:\r\n                return WebGPUConstants.BlendOperation.Min;\r\n            case Constants.GL_ALPHA_EQUATION_MAX:\r\n                return WebGPUConstants.BlendOperation.Max;\r\n            default:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendFactor(factor: Nullable<number>): GPUBlendFactor {\r\n        switch (factor) {\r\n            case 0:\r\n                return WebGPUConstants.BlendFactor.Zero;\r\n            case 1:\r\n                return WebGPUConstants.BlendFactor.One;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC:\r\n                return WebGPUConstants.BlendFactor.Src;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.SrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.DstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.Dst;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusDst;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED:\r\n                return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            default:\r\n                return WebGPUConstants.BlendFactor.One;\r\n        }\r\n    }\r\n\r\n    private static _GetCompareFunction(compareFunction: number): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case 0: // NEVER\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case 1: // LESS\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case 2: // EQUAL\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case 3: // LEQUAL\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case 4: // GREATER\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case 5: // NOTEQUAL\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            case 6: // GEQUAL\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case 7: // ALWAYS\r\n                return WebGPUConstants.CompareFunction.Always;\r\n        }\r\n        return WebGPUConstants.CompareFunction.Never;\r\n    }\r\n\r\n    private static _GetStencilOpFunction(operation: number): GPUStencilOperation {\r\n        switch (operation) {\r\n            case 0:\r\n                return WebGPUConstants.StencilOperation.Zero;\r\n            case 1:\r\n                return WebGPUConstants.StencilOperation.Keep;\r\n            case 2:\r\n                return WebGPUConstants.StencilOperation.Replace;\r\n            case 3:\r\n                return WebGPUConstants.StencilOperation.IncrementClamp;\r\n            case 4:\r\n                return WebGPUConstants.StencilOperation.DecrementClamp;\r\n            case 5:\r\n                return WebGPUConstants.StencilOperation.Invert;\r\n            case 6:\r\n                return WebGPUConstants.StencilOperation.IncrementWrap;\r\n            case 7:\r\n                return WebGPUConstants.StencilOperation.DecrementWrap;\r\n        }\r\n        return WebGPUConstants.StencilOperation.Keep;\r\n    }\r\n\r\n    private static _GetVertexInputDescriptorFormat(vertexBuffer: VertexBuffer): GPUVertexFormat {\r\n        const type = vertexBuffer.type;\r\n        const normalized = vertexBuffer.normalized;\r\n        const size = vertexBuffer.getSize();\r\n\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Sint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Sint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Sint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Sint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Uint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Uint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Uint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Uint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.FLOAT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Float32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Float32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Float32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Float32x4;\r\n                }\r\n                break;\r\n        }\r\n\r\n        throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\r\n    }\r\n\r\n    private _getAphaBlendState(): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1]),\r\n        };\r\n    }\r\n\r\n    private _getColorBlendState(): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0]),\r\n        };\r\n    }\r\n\r\n    private _setShaderStage(id: number): void {\r\n        if (this._shaderId !== id) {\r\n            this._shaderId = id;\r\n            this._states[StatePosition.ShaderStage] = id;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\r\n        }\r\n    }\r\n\r\n    private _setRasterizationState(topology: number, sampleCount: number): void {\r\n        const frontFace = this._frontFace;\r\n        const cullMode = this._cullEnabled ? this._cullFace : 0;\r\n        const clampDepth = this._clampDepth ? 1 : 0;\r\n        const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\r\n        const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\r\n\r\n        if (this._rasterizationState !== rasterizationState) {\r\n            this._rasterizationState = rasterizationState;\r\n            this._states[StatePosition.RasterizationState] = this._rasterizationState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\r\n        }\r\n    }\r\n\r\n    private _setColorStates(): void {\r\n        let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29); // this state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\r\n\r\n        if (this._alphaBlendEnabled) {\r\n            colorStates +=\r\n                ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) +\r\n                ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) +\r\n                ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) +\r\n                ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) +\r\n                ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 0x8005) << 16) +\r\n                ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 0x8005) << 19);\r\n        }\r\n\r\n        if (colorStates !== this._colorStates) {\r\n            this._colorStates = colorStates;\r\n            this._states[StatePosition.ColorStates] = this._colorStates;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);\r\n        }\r\n    }\r\n\r\n    private _setDepthStencilState(): void {\r\n        const stencilState = !this._stencilEnabled\r\n            ? 7 /* ALWAYS */ + (1 /* KEEP */ << 3) + (1 /* KEEP */ << 6) + (1 /* KEEP */ << 9)\r\n            : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);\r\n\r\n        const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) /* ALWAYS */ << 6) + (stencilState << 10); // stencil front - stencil back is the same\r\n\r\n        if (this._depthStencilState !== depthStencilState) {\r\n            this._depthStencilState = depthStencilState;\r\n            this._states[StatePosition.DepthStencilState] = this._depthStencilState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\r\n        }\r\n    }\r\n\r\n    private _setVertexState(effect: Effect): void {\r\n        const currStateLen = this._statesLength;\r\n        let newNumStates = StatePosition.VertexState;\r\n\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let numVertexBuffers = 0;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\r\n            // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\r\n            // See _getVertexInputDescriptor() below\r\n            if (vertexBuffer._validOffsetRange === undefined) {\r\n                const offset = vertexBuffer.effectiveByteOffset;\r\n                const formatSize = vertexBuffer.getSize(true);\r\n                const byteStride = vertexBuffer.effectiveByteStride;\r\n\r\n                vertexBuffer._validOffsetRange =\r\n                    (offset + formatSize <= this._kMaxVertexBufferStride && byteStride === 0) || (byteStride !== 0 && offset + formatSize <= byteStride);\r\n            }\r\n\r\n            if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\r\n                // we can't combine the previous vertexBuffer with the current one\r\n                this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\r\n                currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\r\n            }\r\n\r\n            const vid = vertexBuffer.hashCode + (location << 7);\r\n\r\n            this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\r\n            this._states[newNumStates++] = vid;\r\n        }\r\n\r\n        this.vertexBuffers.length = numVertexBuffers;\r\n\r\n        this._statesLength = newNumStates;\r\n        this._isDirty = this._isDirty || newNumStates !== currStateLen;\r\n        if (this._isDirty) {\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\r\n        }\r\n    }\r\n\r\n    private _setTextureState(textureState: number): void {\r\n        if (this._textureState !== textureState) {\r\n            this._textureState = textureState;\r\n            this._states[StatePosition.TextureStage] = this._textureState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\r\n        }\r\n    }\r\n\r\n    private _createPipelineLayout(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        if (this._useTextureStage) {\r\n            return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: setDefinition,\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[0] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _createPipelineLayoutWithTextureStage(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\r\n        const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        let bitVal = 1;\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.texture) {\r\n                    const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                    const textureInfo = shaderProcessingContext.availableTextures[name];\r\n                    const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + Constants.AUTOSAMPLERSUFFIX] : null;\r\n\r\n                    let sampleType = textureInfo.sampleType;\r\n                    let samplerType = samplerInfo?.type ?? WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n                    if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\r\n                        // The texture is a 32 bits float texture but the system does not support linear filtering for them OR the texture is a depth texture with \"float\" filtering:\r\n                        // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\r\n                        if (textureInfo.autoBindSampler) {\r\n                            samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\r\n                        }\r\n                        sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\r\n                    }\r\n\r\n                    entry.texture!.sampleType = sampleType;\r\n\r\n                    if (samplerInfo) {\r\n                        const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\r\n                        bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler!.type = samplerType;\r\n                    }\r\n\r\n                    bitVal = bitVal << 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: bindGroupLayoutEntries[i],\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[this._textureState] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _getVertexInputDescriptor(effect: Effect): GPUVertexBufferLayout[] {\r\n        const descriptors: GPUVertexBufferLayout[] = [];\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let currentGPUAttributes: GPUVertexAttribute[] | undefined;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            let buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\r\n            let offset = vertexBuffer.effectiveByteOffset;\r\n            const invalidOffsetRange = !vertexBuffer._validOffsetRange;\r\n            if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\r\n                const vertexBufferDescriptor: GPUVertexBufferLayout = {\r\n                    arrayStride: vertexBuffer.effectiveByteStride,\r\n                    stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.VertexStepMode.Instance : WebGPUConstants.VertexStepMode.Vertex,\r\n                    attributes: [],\r\n                };\r\n\r\n                descriptors.push(vertexBufferDescriptor);\r\n                currentGPUAttributes = vertexBufferDescriptor.attributes;\r\n                if (invalidOffsetRange) {\r\n                    offset = 0; // the offset will be set directly in the setVertexBuffer call\r\n                    buffer = null; // buffer can't be reused\r\n                }\r\n            }\r\n\r\n            currentGPUAttributes.push({\r\n                shaderLocation: location,\r\n                offset,\r\n                format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer),\r\n            });\r\n\r\n            currentGPUBuffer = buffer;\r\n        }\r\n\r\n        return descriptors;\r\n    }\r\n\r\n    private _createRenderPipeline(effect: Effect, topology: GPUPrimitiveTopology, sampleCount: number): GPURenderPipeline {\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const inputStateDescriptor = this._getVertexInputDescriptor(effect);\r\n        const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\r\n\r\n        const colorStates: Array<GPUColorTargetState | null> = [];\r\n        const alphaBlend = this._getAphaBlendState();\r\n        const colorBlend = this._getColorBlendState();\r\n\r\n        if (this._vertexBuffers) {\r\n            checkNonFloatVertexBuffers(this._vertexBuffers, effect);\r\n        }\r\n\r\n        if (this._mrtAttachments1 > 0) {\r\n            for (let i = 0; i < this._mrtFormats.length; ++i) {\r\n                const format = this._mrtFormats[i];\r\n                if (format) {\r\n                    const descr: GPUColorTargetState = {\r\n                        format,\r\n                        writeMask: (this._mrtEnabledMask & (1 << i)) !== 0 ? this._writeMask : 0,\r\n                    };\r\n                    if (alphaBlend && colorBlend) {\r\n                        descr.blend = {\r\n                            alpha: alphaBlend,\r\n                            color: colorBlend,\r\n                        };\r\n                    }\r\n                    colorStates.push(descr);\r\n                } else {\r\n                    colorStates.push(null);\r\n                }\r\n            }\r\n        } else {\r\n            if (this._webgpuColorFormat[0]) {\r\n                const descr: GPUColorTargetState = {\r\n                    format: this._webgpuColorFormat[0],\r\n                    writeMask: this._writeMask,\r\n                };\r\n                if (alphaBlend && colorBlend) {\r\n                    descr.blend = {\r\n                        alpha: alphaBlend,\r\n                        color: colorBlend,\r\n                    };\r\n                }\r\n                colorStates.push(descr);\r\n            } else {\r\n                colorStates.push(null);\r\n            }\r\n        }\r\n\r\n        const stencilFrontBack: GPUStencilFaceState = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        let stripIndexFormat: GPUIndexFormat | undefined = undefined;\r\n        if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\r\n            stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\r\n        }\r\n\r\n        const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\r\n\r\n        return this._device.createRenderPipeline({\r\n            label: `RenderPipeline_${colorStates[0]?.format ?? \"nooutput\"}_${this._webgpuDepthStencilFormat ?? \"nodepth\"}_samples${sampleCount}_textureState${this._textureState}`,\r\n            layout: pipelineLayout,\r\n            vertex: {\r\n                module: webgpuPipelineContext.stages!.vertexStage.module,\r\n                entryPoint: webgpuPipelineContext.stages!.vertexStage.entryPoint,\r\n                buffers: inputStateDescriptor,\r\n            },\r\n            primitive: {\r\n                topology,\r\n                stripIndexFormat,\r\n                frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\r\n                cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back,\r\n            },\r\n            fragment: !webgpuPipelineContext.stages!.fragmentStage\r\n                ? undefined\r\n                : {\r\n                      module: webgpuPipelineContext.stages!.fragmentStage.module,\r\n                      entryPoint: webgpuPipelineContext.stages!.fragmentStage.entryPoint,\r\n                      targets: colorStates,\r\n                  },\r\n\r\n            multisample: {\r\n                count: sampleCount,\r\n                /*mask,\r\n                alphaToCoverageEnabled,*/\r\n            },\r\n            depthStencil:\r\n                this._webgpuDepthStencilFormat === undefined\r\n                    ? undefined\r\n                    : {\r\n                          depthWriteEnabled: this._depthWriteEnabled,\r\n                          depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\r\n                          format: this._webgpuDepthStencilFormat,\r\n                          stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\r\n                          stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\r\n                          stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\r\n                          stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\r\n                          depthBias: this._depthBias,\r\n                          depthBiasClamp: this._depthBiasClamp,\r\n                          depthBiasSlopeScale: this._depthBiasSlopeScale,\r\n                      },\r\n        });\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\n\r\n/** @internal */\r\nclass NodeState {\r\n    public values: { [id: number]: NodeState };\r\n    public pipeline: GPURenderPipeline;\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n\r\n    public count(): [number, number] {\r\n        let countNode = 0,\r\n            countPipeline = this.pipeline ? 1 : 0;\r\n        for (const value in this.values) {\r\n            const node = this.values[value];\r\n            const [childCountNodes, childCoundPipeline] = node!.count();\r\n            countNode += childCountNodes;\r\n            countPipeline += childCoundPipeline;\r\n            countNode++;\r\n        }\r\n        return [countNode, countPipeline];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {\r\n    private static _Cache: NodeState = new NodeState();\r\n\r\n    private _nodeStack: NodeState[];\r\n\r\n    public static GetNodeCounts(): { nodeCount: number; pipelineCount: number } {\r\n        const counts = WebGPUCacheRenderPipelineTree._Cache.count();\r\n\r\n        return { nodeCount: counts[0], pipelineCount: counts[1] };\r\n    }\r\n\r\n    public static _GetPipelines(node: NodeState, pipelines: Array<Array<number>>, curPath: Array<number>, curPathLen: number): void {\r\n        if (node.pipeline) {\r\n            const path = curPath.slice();\r\n            path.length = curPathLen;\r\n            pipelines.push(path);\r\n        }\r\n        for (const value in node.values) {\r\n            const nnode = node.values[value];\r\n            curPath[curPathLen] = parseInt(value);\r\n            WebGPUCacheRenderPipelineTree._GetPipelines(nnode, pipelines, curPath, curPathLen + 1);\r\n        }\r\n    }\r\n\r\n    public static GetPipelines(): Array<Array<number>> {\r\n        const pipelines: Array<Array<number>> = [];\r\n        WebGPUCacheRenderPipelineTree._GetPipelines(WebGPUCacheRenderPipelineTree._Cache, pipelines, [], 0);\r\n        return pipelines;\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheRenderPipelineTree._Cache = new NodeState();\r\n    }\r\n\r\n    public override reset(): void {\r\n        this._nodeStack = [];\r\n        this._nodeStack[0] = WebGPUCacheRenderPipelineTree._Cache;\r\n        super.reset();\r\n    }\r\n\r\n    protected _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        let node = this._nodeStack[this._stateDirtyLowestIndex];\r\n        for (let i = this._stateDirtyLowestIndex; i < this._statesLength; ++i) {\r\n            let nn: NodeState | undefined = node!.values[this._states[i]];\r\n            if (!nn) {\r\n                nn = new NodeState();\r\n                node!.values[this._states[i]] = nn;\r\n            }\r\n            node = nn;\r\n            this._nodeStack[i + 1] = node;\r\n        }\r\n\r\n        param.token = node;\r\n        param.pipeline = node.pipeline;\r\n    }\r\n\r\n    protected _setRenderPipeline(param: { token: NodeState; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        param.token.pipeline = param.pipeline!;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Constants } from \"../constants\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nconst filterToBits = [\r\n    0 | (0 << 1) | (0 << 2), // not used\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    1 | (1 << 1) | (1 << 2), // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 | (1 << 1) | (1 << 2), // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR\r\n    0 | (0 << 1) | (1 << 2), // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    1 | (0 << 1) | (1 << 2), // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n// subtract 0x01FF from the comparison function value before indexing this array!\r\nconst comparisonFunctionToBits = [\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // undefined\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (1 << 6), // NEVER\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (0 << 6), // LESS\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (1 << 6), // EQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (0 << 6), // LEQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (1 << 6), // GREATER\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (0 << 6), // NOTEQUAL\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (1 << 6), // GEQUAL\r\n    (1 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // ALWAYS\r\n];\r\n\r\nconst filterNoMipToBits = [\r\n    0 << 7, // not used\r\n    1 << 7, // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 << 7, // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    0 << 7, // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    1 << 7, // TEXTURE_NEAREST_LINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 << 7, // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n/** @internal */\r\nexport class WebGPUCacheSampler {\r\n    private _samplers: { [hash: number]: GPUSampler } = {};\r\n    private _device: GPUDevice;\r\n\r\n    public disabled: boolean;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this.disabled = false;\r\n    }\r\n\r\n    public static GetSamplerHashCode(sampler: TextureSampler): number {\r\n        // The WebGPU spec currently only allows values 1 and 4 for anisotropy\r\n        const anisotropy = sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;\r\n        const code =\r\n            filterToBits[sampler.samplingMode] +\r\n            comparisonFunctionToBits[(sampler._comparisonFunction || 0x0202) - 0x0200 + 1] +\r\n            filterNoMipToBits[sampler.samplingMode] + // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping\r\n            ((sampler._cachedWrapU ?? 1) << 8) +\r\n            ((sampler._cachedWrapV ?? 1) << 10) +\r\n            ((sampler._cachedWrapR ?? 1) << 12) +\r\n            ((sampler.useMipMaps ? 1 : 0) << 14) + // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND useMipMaps!\r\n            (anisotropy << 15);\r\n\r\n        return code;\r\n    }\r\n\r\n    private static _GetSamplerFilterDescriptor(\r\n        sampler: TextureSampler,\r\n        anisotropy: number\r\n    ): {\r\n        magFilter: GPUFilterMode;\r\n        minFilter: GPUFilterMode;\r\n        mipmapFilter: GPUFilterMode;\r\n        lodMinClamp?: number;\r\n        lodMaxClamp?: number;\r\n        anisotropyEnabled?: boolean;\r\n    } {\r\n        let magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUFilterMode, lodMinClamp: number | undefined, lodMaxClamp: number | undefined;\r\n        const useMipMaps = sampler.useMipMaps;\r\n        switch (sampler.samplingMode) {\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n            case Constants.TEXTURE_TRILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST:\r\n            case Constants.TEXTURE_NEAREST_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR:\r\n            case Constants.TEXTURE_BILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            default:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n        }\r\n\r\n        if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0) && mipmapFilter !== WebGPUConstants.FilterMode.Nearest) {\r\n            return {\r\n                magFilter: WebGPUConstants.FilterMode.Linear,\r\n                minFilter: WebGPUConstants.FilterMode.Linear,\r\n                mipmapFilter: WebGPUConstants.FilterMode.Linear,\r\n                anisotropyEnabled: true,\r\n            };\r\n        }\r\n\r\n        return {\r\n            magFilter,\r\n            minFilter,\r\n            mipmapFilter,\r\n            lodMinClamp,\r\n            lodMaxClamp,\r\n        };\r\n    }\r\n\r\n    private static _GetWrappingMode(mode: number): GPUAddressMode {\r\n        switch (mode) {\r\n            case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.Repeat;\r\n            case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.ClampToEdge;\r\n            case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.MirrorRepeat;\r\n        }\r\n        return WebGPUConstants.AddressMode.Repeat;\r\n    }\r\n\r\n    private static _GetSamplerWrappingDescriptor(sampler: TextureSampler): {\r\n        addressModeU: GPUAddressMode;\r\n        addressModeV: GPUAddressMode;\r\n        addressModeW: GPUAddressMode;\r\n    } {\r\n        return {\r\n            addressModeU: this._GetWrappingMode(sampler._cachedWrapU!),\r\n            addressModeV: this._GetWrappingMode(sampler._cachedWrapV!),\r\n            addressModeW: this._GetWrappingMode(sampler._cachedWrapR!),\r\n        };\r\n    }\r\n\r\n    private static _GetSamplerDescriptor(sampler: TextureSampler, label?: string): GPUSamplerDescriptor {\r\n        // The WebGPU spec currently only allows values 1 and 4 for anisotropy\r\n        const anisotropy = sampler.useMipMaps && sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;\r\n        const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);\r\n        return {\r\n            label,\r\n            ...filterDescriptor,\r\n            ...this._GetSamplerWrappingDescriptor(sampler),\r\n            compare: sampler._comparisonFunction ? WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : undefined,\r\n            maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1,\r\n        };\r\n    }\r\n\r\n    public static GetCompareFunction(compareFunction: Nullable<number>): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case Constants.ALWAYS:\r\n                return WebGPUConstants.CompareFunction.Always;\r\n            case Constants.EQUAL:\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case Constants.GREATER:\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case Constants.GEQUAL:\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case Constants.LESS:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case Constants.LEQUAL:\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case Constants.NEVER:\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case Constants.NOTEQUAL:\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            default:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n        }\r\n    }\r\n\r\n    public getSampler(sampler: TextureSampler, bypassCache = false, hash = 0, label?: string): GPUSampler {\r\n        if (this.disabled) {\r\n            return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n        }\r\n\r\n        if (bypassCache) {\r\n            hash = 0;\r\n        } else if (hash === 0) {\r\n            hash = WebGPUCacheSampler.GetSamplerHashCode(sampler);\r\n        }\r\n\r\n        let gpuSampler = bypassCache ? undefined : this._samplers[hash];\r\n        if (!gpuSampler) {\r\n            gpuSampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n            if (!bypassCache) {\r\n                this._samplers[hash] = gpuSampler;\r\n            }\r\n        }\r\n\r\n        return gpuSampler;\r\n    }\r\n}\r\n","import type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IColor4Like } from \"../../Maths/math.like\";\r\nimport type { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./webgpuCacheRenderPipelineTree\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\n\r\nimport \"../../ShadersWGSL/clearQuad.vertex\";\r\nimport \"../../ShadersWGSL/clearQuad.fragment\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport class WebGPUClearQuad {\r\n    private _device: GPUDevice;\r\n    private _engine: WebGPUEngine;\r\n    private _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _effect: Effect;\r\n    private _bindGroups: { [id: string]: GPUBindGroup[] } = {};\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _bundleCache: { [key: string]: GPURenderBundle } = {};\r\n    private _keyTemp: number[] = [];\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._depthTextureFormat = format;\r\n        this._cacheRenderPipeline.setDepthStencilFormat(format);\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n    }\r\n\r\n    public setMRTAttachments(attachments: number[], textureArray: InternalTexture[], textureCount: number): void {\r\n        this._cacheRenderPipeline.setMRT(textureArray, textureCount);\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    }\r\n\r\n    constructor(device: GPUDevice, engine: WebGPUEngine, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._engine = engine;\r\n\r\n        this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer);\r\n        this._cacheRenderPipeline.setDepthTestEnabled(false);\r\n        this._cacheRenderPipeline.setStencilReadMask(0xff);\r\n\r\n        this._effect = engine.createEffect(\"clearQuad\", [], [\"color\", \"depthValue\"], undefined, undefined, undefined, undefined, undefined, undefined, ShaderLanguage.WGSL);\r\n    }\r\n\r\n    public clear(\r\n        renderPass: Nullable<GPURenderPassEncoder>,\r\n        clearColor?: Nullable<IColor4Like>,\r\n        clearDepth?: boolean,\r\n        clearStencil?: boolean,\r\n        sampleCount = 1\r\n    ): Nullable<GPURenderBundle> {\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder;\r\n        let bundle: Nullable<GPURenderBundle> = null;\r\n        let bundleKey: string;\r\n\r\n        const isRTTPass = !!this._engine._currentRenderTarget;\r\n\r\n        if (renderPass) {\r\n            renderPass2 = renderPass;\r\n        } else {\r\n            let idx = 0;\r\n            this._keyTemp.length = 0;\r\n            for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {\r\n                this._keyTemp[idx++] = renderableTextureFormatToIndex[this._cacheRenderPipeline.colorFormats[i] ?? \"\"];\r\n            }\r\n\r\n            const depthStencilFormatIndex = renderableTextureFormatToIndex[this._depthTextureFormat ?? 0];\r\n\r\n            this._keyTemp[idx] =\r\n                (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) +\r\n                (clearDepth ? 2 ** 32 : 0) +\r\n                (clearStencil ? 2 ** 33 : 0) +\r\n                (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) +\r\n                (isRTTPass ? 2 ** 35 : 0) +\r\n                (sampleCount > 1 ? 2 ** 36 : 0) +\r\n                depthStencilFormatIndex * 2 ** 37;\r\n\r\n            bundleKey = this._keyTemp.join(\"_\");\r\n            bundle = this._bundleCache[bundleKey];\r\n\r\n            if (bundle) {\r\n                return bundle;\r\n            }\r\n\r\n            renderPass2 = this._device.createRenderBundleEncoder({\r\n                label: \"clearQuadRenderBundle\",\r\n                colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                depthStencilFormat: this._depthTextureFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);\r\n        this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));\r\n        this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 0xff : 0);\r\n        this._cacheRenderPipeline.setStencilCompare(clearStencil ? Constants.ALWAYS : Constants.NEVER);\r\n        this._cacheRenderPipeline.setStencilPassOp(clearStencil ? Constants.REPLACE : Constants.KEEP);\r\n        this._cacheRenderPipeline.setWriteMask(clearColor ? 0xf : 0);\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(Constants.MATERIAL_TriangleStripDrawMode, this._effect, sampleCount);\r\n\r\n        const webgpuPipelineContext = this._effect._pipelineContext as WebGPUPipelineContext;\r\n\r\n        if (clearColor) {\r\n            this._effect.setDirectColor4(\"color\", clearColor);\r\n        }\r\n\r\n        this._effect.setFloat(\"depthValue\", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);\r\n\r\n        webgpuPipelineContext.uniformBuffer!.update();\r\n\r\n        const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;\r\n        const bufferLeftOver = webgpuPipelineContext.uniformBuffer!.getBuffer() as WebGPUDataBuffer;\r\n\r\n        const key = bufferLeftOver.uniqueId + \"-\" + bufferInternals.uniqueId;\r\n\r\n        let bindGroups = this._bindGroups[key];\r\n\r\n        if (!bindGroups) {\r\n            const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[0];\r\n            bindGroups = this._bindGroups[key] = [];\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup0-${key}`,\r\n                    layout: bindGroupLayouts[0],\r\n                    entries: [],\r\n                })\r\n            );\r\n            if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {\r\n                bindGroups.push(\r\n                    this._device.createBindGroup({\r\n                        label: `clearQuadBindGroup1-${key}`,\r\n                        layout: bindGroupLayouts[1],\r\n                        entries: [],\r\n                    })\r\n                );\r\n            }\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup${WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2}-${key}`,\r\n                    layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: {\r\n                                buffer: bufferInternals.underlyingResource,\r\n                                size: bufferInternals.capacity,\r\n                            },\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: {\r\n                                buffer: bufferLeftOver.underlyingResource,\r\n                                size: bufferLeftOver.capacity,\r\n                            },\r\n                        },\r\n                    ],\r\n                })\r\n            );\r\n        }\r\n\r\n        renderPass2.setPipeline(pipeline);\r\n        for (let i = 0; i < bindGroups.length; ++i) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n        renderPass2.draw(4, 1, 0, 0);\r\n\r\n        if (!renderPass) {\r\n            bundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            this._bundleCache[bundleKey!] = bundle;\r\n        }\r\n\r\n        return bundle;\r\n    }\r\n}\r\n","/** @internal */\r\n// eslint-disable-next-line import/export\r\nexport const enum PowerPreference {\r\n    LowPower = \"low-power\",\r\n    HighPerformance = \"high-performance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FeatureName {\r\n    DepthClipControl = \"depth-clip-control\",\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n    TextureCompressionBC = \"texture-compression-bc\",\r\n    TextureCompressionETC2 = \"texture-compression-etc2\",\r\n    TextureCompressionASTC = \"texture-compression-astc\",\r\n    TimestampQuery = \"timestamp-query\",\r\n    IndirectFirstInstance = \"indirect-first-instance\",\r\n    ShaderF16 = \"shader-f16\",\r\n    RG11B10UFloatRenderable = \"rg11b10ufloat-renderable\",\r\n    BGRA8UnormStorage = \"bgra8unorm-storage\",\r\n    Float32Filterable = \"float32-filterable\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferMapState {\r\n    Unmapped = \"unmapped\",\r\n    Pending = \"pending\",\r\n    Mapped = \"mapped\",\r\n}\r\n\r\n/** @internal */\r\nexport enum BufferUsage {\r\n    MapRead = 1,\r\n    MapWrite = 2,\r\n    CopySrc = 4,\r\n    CopyDst = 8,\r\n    Index = 16,\r\n    Vertex = 32,\r\n    Uniform = 64,\r\n    Storage = 128,\r\n    Indirect = 256,\r\n    QueryResolve = 512,\r\n}\r\n\r\n/** @internal */\r\nexport const enum MapMode {\r\n    Read = 1,\r\n    Write = 2,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureUsage {\r\n    CopySrc = 1,\r\n    CopyDst = 2,\r\n    TextureBinding = 4,\r\n    StorageBinding = 8,\r\n    RenderAttachment = 16,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureViewDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E2dArray = \"2d-array\",\r\n    Cube = \"cube\",\r\n    CubeArray = \"cube-array\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureAspect {\r\n    All = \"all\",\r\n    StencilOnly = \"stencil-only\",\r\n    DepthOnly = \"depth-only\",\r\n}\r\n\r\n/**\r\n * Comments taken from https://github.com/gfx-rs/wgpu/blob/master/wgpu-types/src/lib.rs\r\n * @internal\r\n */\r\nexport const enum TextureFormat {\r\n    // 8-bit formats\r\n    R8Unorm = \"r8unorm\", // Red channel only. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    R8Snorm = \"r8snorm\", // Red channel only. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    R8Uint = \"r8uint\", // Red channel only. 8 bit integer per channel. Unsigned in shader.\r\n    R8Sint = \"r8sint\", // Red channel only. 8 bit integer per channel. Signed in shader.\r\n\r\n    // 16-bit formats\r\n    R16Uint = \"r16uint\", // Red channel only. 16 bit integer per channel. Unsigned in shader.\r\n    R16Sint = \"r16sint\", // Red channel only. 16 bit integer per channel. Signed in shader.\r\n    R16Float = \"r16float\", // Red channel only. 16 bit float per channel. Float in shader.\r\n    RG8Unorm = \"rg8unorm\", // Red and green channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RG8Snorm = \"rg8snorm\", // Red and green channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RG8Uint = \"rg8uint\", // Red and green channels. 8 bit integer per channel. Unsigned in shader.\r\n    RG8Sint = \"rg8sint\", // Red and green channels. 8 bit integer per channel. Signed in shader.\r\n\r\n    // 32-bit formats\r\n    R32Uint = \"r32uint\", // Red channel only. 32 bit integer per channel. Unsigned in shader.\r\n    R32Sint = \"r32sint\", // Red channel only. 32 bit integer per channel. Signed in shader.\r\n    R32Float = \"r32float\", // Red channel only. 32 bit float per channel. Float in shader.\r\n    RG16Uint = \"rg16uint\", // Red and green channels. 16 bit integer per channel. Unsigned in shader.\r\n    RG16Sint = \"rg16sint\", // Red and green channels. 16 bit integer per channel. Signed in shader.\r\n    RG16Float = \"rg16float\", // Red and green channels. 16 bit float per channel. Float in shader.\r\n    RGBA8Unorm = \"rgba8unorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RGBA8UnormSRGB = \"rgba8unorm-srgb\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    RGBA8Snorm = \"rgba8snorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RGBA8Uint = \"rgba8uint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Unsigned in shader.\r\n    RGBA8Sint = \"rgba8sint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Signed in shader.\r\n    BGRA8Unorm = \"bgra8unorm\", // Blue, green, red, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    BGRA8UnormSRGB = \"bgra8unorm-srgb\", // Blue, green, red, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    // Packed 32-bit formats\r\n    RGB9E5UFloat = \"rgb9e5ufloat\", // Packed unsigned float with 9 bits mantisa for each RGB component, then a common 5 bits exponent\r\n    RGB10A2UINT = \"rgb10a2uint\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha).\r\n    RGB10A2Unorm = \"rgb10a2unorm\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha) converted to/from float [0, 1] in shader.\r\n    RG11B10UFloat = \"rg11b10ufloat\", // Red, green, and blue channels. 11 bit float with no sign bit for RG channels. 10 bit float with no sign bit for blue channel. Float in shader.\r\n\r\n    // 64-bit formats\r\n    RG32Uint = \"rg32uint\", // Red and green channels. 32 bit integer per channel. Unsigned in shader.\r\n    RG32Sint = \"rg32sint\", // Red and green channels. 32 bit integer per channel. Signed in shader.\r\n    RG32Float = \"rg32float\", // Red and green channels. 32 bit float per channel. Float in shader.\r\n    RGBA16Uint = \"rgba16uint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Unsigned in shader.\r\n    RGBA16Sint = \"rgba16sint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Signed in shader.\r\n    RGBA16Float = \"rgba16float\", // Red, green, blue, and alpha channels. 16 bit float per channel. Float in shader.\r\n\r\n    // 128-bit formats\r\n    RGBA32Uint = \"rgba32uint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Unsigned in shader.\r\n    RGBA32Sint = \"rgba32sint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Signed in shader.\r\n    RGBA32Float = \"rgba32float\", // Red, green, blue, and alpha channels. 32 bit float per channel. Float in shader.\r\n\r\n    // Depth and stencil formats\r\n    Stencil8 = \"stencil8\",\r\n    Depth16Unorm = \"depth16unorm\",\r\n    Depth24Plus = \"depth24plus\", // Special depth format with at least 24 bit integer depth.\r\n    Depth24PlusStencil8 = \"depth24plus-stencil8\", // Special depth/stencil format with at least 24 bit integer depth and 8 bits integer stencil.\r\n    Depth32Float = \"depth32float\", // Special depth format with 32 bit floating point depth.\r\n\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    BC1RGBAUnorm = \"bc1-rgba-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC1RGBAUnormSRGB = \"bc1-rgba-unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC2RGBAUnorm = \"bc2-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC2RGBAUnormSRGB = \"bc2-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC3RGBAUnorm = \"bc3-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC3RGBAUnormSRGB = \"bc3-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC4RUnorm = \"bc4-r-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC4RSnorm = \"bc4-r-snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC5RGUnorm = \"bc5-rg-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC5RGSnorm = \"bc5-rg-snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC6HRGBUFloat = \"bc6h-rgb-ufloat\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit unsigned float RGB. Float in shader. Also known as BPTC (float).\r\n    BC6HRGBFloat = \"bc6h-rgb-float\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit signed float RGB. Float in shader. Also known as BPTC (float).\r\n    BC7RGBAUnorm = \"bc7-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n    BC7RGBAUnormSRGB = \"bc7-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ETC2RGB8Unorm = \"etc2-rgb8unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8UnormSRGB = \"etc2-rgb8unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8A1Unorm = \"etc2-rgb8a1unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGB8A1UnormSRGB = \"etc2-rgb8a1unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGBA8Unorm = \"etc2-rgba8unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    ETC2RGBA8UnormSRGB = \"etc2-rgba8unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    EACR11Unorm = \"eac-r11unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACR11Snorm = \"eac-r11snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACRG11Unorm = \"eac-rg11unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n    EACRG11Snorm = \"eac-rg11snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ASTC4x4Unorm = \"astc-4x4-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC4x4UnormSRGB = \"astc-4x4-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4Unorm = \"astc-5x4-unorm\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4UnormSRGB = \"astc-5x4-unorm-srgb\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5Unorm = \"astc-5x5-unorm\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5UnormSRGB = \"astc-5x5-unorm-srgb\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5Unorm = \"astc-6x5-unorm\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5UnormSRGB = \"astc-6x5-unorm-srgb\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6Unorm = \"astc-6x6-unorm\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6UnormSRGB = \"astc-6x6-unorm-srgb\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5Unorm = \"astc-8x5-unorm\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5UnormSRGB = \"astc-8x5-unorm-srgb\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6Unorm = \"astc-8x6-unorm\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6UnormSRGB = \"astc-8x6-unorm-srgb\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8Unorm = \"astc-8x8-unorm\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8UnormSRGB = \"astc-8x8-unorm-srgb\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5Unorm = \"astc-10x5-unorm\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5UnormSRGB = \"astc-10x5-unorm-srgb\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6Unorm = \"astc-10x6-unorm\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6UnormSRGB = \"astc-10x6-unorm-srgb\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8Unorm = \"astc-10x8-unorm\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8UnormSRGB = \"astc-10x8-unorm-srgb\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10Unorm = \"astc-10x10-unorm\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10UnormSRGB = \"astc-10x10-unorm-srgb\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10Unorm = \"astc-12x10-unorm\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10UnormSRGB = \"astc-12x10-unorm-srgb\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12Unorm = \"astc-12x12-unorm\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12UnormSRGB = \"astc-12x12-unorm-srgb\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n\r\n    // \"depth32float-stencil8\" feature\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AddressMode {\r\n    ClampToEdge = \"clamp-to-edge\",\r\n    Repeat = \"repeat\",\r\n    MirrorRepeat = \"mirror-repeat\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum MipmapFilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompareFunction {\r\n    Never = \"never\",\r\n    Less = \"less\",\r\n    Equal = \"equal\",\r\n    LessEqual = \"less-equal\",\r\n    Greater = \"greater\",\r\n    NotEqual = \"not-equal\",\r\n    GreaterEqual = \"greater-equal\",\r\n    Always = \"always\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ShaderStage {\r\n    Vertex = 1,\r\n    Fragment = 2,\r\n    Compute = 4,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferBindingType {\r\n    Uniform = \"uniform\",\r\n    Storage = \"storage\",\r\n    ReadOnlyStorage = \"read-only-storage\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum SamplerBindingType {\r\n    Filtering = \"filtering\",\r\n    NonFiltering = \"non-filtering\",\r\n    Comparison = \"comparison\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureSampleType {\r\n    Float = \"float\",\r\n    UnfilterableFloat = \"unfilterable-float\",\r\n    Depth = \"depth\",\r\n    Sint = \"sint\",\r\n    Uint = \"uint\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StorageTextureAccess {\r\n    WriteOnly = \"write-only\",\r\n    ReadOnly = \"read-only\",\r\n    ReadWrite = \"read-write\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompilationMessageType {\r\n    Error = \"error\",\r\n    Warning = \"warning\",\r\n    Info = \"info\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PipelineErrorReason {\r\n    Validation = \"validation\",\r\n    Internal = \"internal\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AutoLayoutMode {\r\n    Auto = \"auto\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PrimitiveTopology {\r\n    PointList = \"point-list\",\r\n    LineList = \"line-list\",\r\n    LineStrip = \"line-strip\",\r\n    TriangleList = \"triangle-list\",\r\n    TriangleStrip = \"triangle-strip\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FrontFace {\r\n    CCW = \"ccw\",\r\n    CW = \"cw\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CullMode {\r\n    None = \"none\",\r\n    Front = \"front\",\r\n    Back = \"back\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ColorWrite {\r\n    Red = 1,\r\n    Green = 2,\r\n    Blue = 4,\r\n    Alpha = 8,\r\n    All = 15,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendFactor {\r\n    Zero = \"zero\",\r\n    One = \"one\",\r\n    Src = \"src\",\r\n    OneMinusSrc = \"one-minus-src\",\r\n    SrcAlpha = \"src-alpha\",\r\n    OneMinusSrcAlpha = \"one-minus-src-alpha\",\r\n    Dst = \"dst\",\r\n    OneMinusDst = \"one-minus-dst\",\r\n    DstAlpha = \"dst-alpha\",\r\n    OneMinusDstAlpha = \"one-minus-dst-alpha\",\r\n    SrcAlphaSaturated = \"src-alpha-saturated\",\r\n    Constant = \"constant\",\r\n    OneMinusConstant = \"one-minus-constant\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendOperation {\r\n    Add = \"add\",\r\n    Subtract = \"subtract\",\r\n    ReverseSubtract = \"reverse-subtract\",\r\n    Min = \"min\",\r\n    Max = \"max\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StencilOperation {\r\n    Keep = \"keep\",\r\n    Zero = \"zero\",\r\n    Replace = \"replace\",\r\n    Invert = \"invert\",\r\n    IncrementClamp = \"increment-clamp\",\r\n    DecrementClamp = \"decrement-clamp\",\r\n    IncrementWrap = \"increment-wrap\",\r\n    DecrementWrap = \"decrement-wrap\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum IndexFormat {\r\n    Uint16 = \"uint16\",\r\n    Uint32 = \"uint32\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexFormat {\r\n    Uint8x2 = \"uint8x2\",\r\n    Uint8x4 = \"uint8x4\",\r\n    Sint8x2 = \"sint8x2\",\r\n    Sint8x4 = \"sint8x4\",\r\n    Unorm8x2 = \"unorm8x2\",\r\n    Unorm8x4 = \"unorm8x4\",\r\n    Snorm8x2 = \"snorm8x2\",\r\n    Snorm8x4 = \"snorm8x4\",\r\n    Uint16x2 = \"uint16x2\",\r\n    Uint16x4 = \"uint16x4\",\r\n    Sint16x2 = \"sint16x2\",\r\n    Sint16x4 = \"sint16x4\",\r\n    Unorm16x2 = \"unorm16x2\",\r\n    Unorm16x4 = \"unorm16x4\",\r\n    Snorm16x2 = \"snorm16x2\",\r\n    Snorm16x4 = \"snorm16x4\",\r\n    Float16x2 = \"float16x2\",\r\n    Float16x4 = \"float16x4\",\r\n    Float32 = \"float32\",\r\n    Float32x2 = \"float32x2\",\r\n    Float32x3 = \"float32x3\",\r\n    Float32x4 = \"float32x4\",\r\n    Uint32 = \"uint32\",\r\n    Uint32x2 = \"uint32x2\",\r\n    Uint32x3 = \"uint32x3\",\r\n    Uint32x4 = \"uint32x4\",\r\n    Sint32 = \"sint32\",\r\n    Sint32x2 = \"sint32x2\",\r\n    Sint32x3 = \"sint32x3\",\r\n    Sint32x4 = \"sint32x4\",\r\n    UNORM10x10x10x2 = \"unorm10-10-10-2\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexStepMode {\r\n    Vertex = \"vertex\",\r\n    Instance = \"instance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ComputePassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum RenderPassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum LoadOp {\r\n    Load = \"load\",\r\n    Clear = \"clear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StoreOp {\r\n    Store = \"store\",\r\n    Discard = \"discard\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum QueryType {\r\n    Occlusion = \"occlusion\",\r\n    Timestamp = \"timestamp\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CanvasAlphaMode {\r\n    Opaque = \"opaque\",\r\n    Premultiplied = \"premultiplied\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum DeviceLostReason {\r\n    Unknown = \"unknown\",\r\n    Destroyed = \"destroyed\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ErrorFilter {\r\n    Validation = \"validation\",\r\n    OutOfMemory = \"out-of-memory\",\r\n    Internal = \"internal\",\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { DepthCullingState } from \"../../States/depthCullingState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUDepthCullingState extends DepthCullingState {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     * @param cache\r\n     */\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get zOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    public override set zOffset(value: number) {\r\n        if (this._zOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffset = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBiasSlopeScale(value);\r\n    }\r\n\r\n    public override get zOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    public override set zOffsetUnits(value: number) {\r\n        if (this._zOffsetUnits === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffsetUnits = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBias(value);\r\n    }\r\n\r\n    public override get cullFace(): Nullable<number> {\r\n        return this._cullFace;\r\n    }\r\n\r\n    public override set cullFace(value: Nullable<number>) {\r\n        if (this._cullFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._cullFace = value;\r\n        this._isCullFaceDirty = true;\r\n        this._cache.setCullFace(value ?? 1);\r\n    }\r\n\r\n    public override get cull(): Nullable<boolean> {\r\n        return this._cull;\r\n    }\r\n\r\n    public override set cull(value: Nullable<boolean>) {\r\n        if (this._cull === value) {\r\n            return;\r\n        }\r\n\r\n        this._cull = value;\r\n        this._isCullDirty = true;\r\n        this._cache.setCullEnabled(!!value);\r\n    }\r\n\r\n    public override get depthFunc(): Nullable<number> {\r\n        return this._depthFunc;\r\n    }\r\n\r\n    public override set depthFunc(value: Nullable<number>) {\r\n        if (this._depthFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthFunc = value;\r\n        this._isDepthFuncDirty = true;\r\n        this._cache.setDepthCompare(value);\r\n    }\r\n\r\n    public override get depthMask(): boolean {\r\n        return this._depthMask;\r\n    }\r\n\r\n    public override set depthMask(value: boolean) {\r\n        if (this._depthMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthMask = value;\r\n        this._isDepthMaskDirty = true;\r\n        this._cache.setDepthWriteEnabled(value);\r\n    }\r\n\r\n    public override get depthTest(): boolean {\r\n        return this._depthTest;\r\n    }\r\n\r\n    public override set depthTest(value: boolean) {\r\n        if (this._depthTest === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthTest = value;\r\n        this._isDepthTestDirty = true;\r\n        this._cache.setDepthTestEnabled(value);\r\n    }\r\n\r\n    public override get frontFace(): Nullable<number> {\r\n        return this._frontFace;\r\n    }\r\n\r\n    public override set frontFace(value: Nullable<number>) {\r\n        if (this._frontFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._frontFace = value;\r\n        this._isFrontFaceDirty = true;\r\n        this._cache.setFrontFace(value ?? 2);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetDepthCullingState();\r\n    }\r\n\r\n    public override apply() {\r\n        // nothing to do\r\n    }\r\n}\r\n","import type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDrawContext } from \"../IDrawContext\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUDrawContext implements IDrawContext {\r\n    private static _Counter = 0;\r\n\r\n    public fastBundle?: GPURenderBundle; // used only when compatibilityMode==false (fast mode)\r\n    public bindGroups?: GPUBindGroup[]; // cache of the bind groups. Will be reused for the next draw if isDirty==false (and materialContext.isDirty==false)\r\n\r\n    public uniqueId: number;\r\n\r\n    public buffers: { [name: string]: Nullable<WebGPUDataBuffer> };\r\n\r\n    public indirectDrawBuffer?: GPUBuffer;\r\n\r\n    private _materialContextUpdateId: number;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _useInstancing: boolean;\r\n    private _indirectDrawData?: Uint32Array;\r\n    private _currentInstanceCount: number;\r\n    private _isDirty: boolean;\r\n\r\n    public isDirty(materialContextUpdateId: number): boolean {\r\n        return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\r\n    }\r\n\r\n    public resetIsDirty(materialContextUpdateId: number): void {\r\n        this._isDirty = false;\r\n        this._materialContextUpdateId = materialContextUpdateId;\r\n    }\r\n\r\n    public get useInstancing() {\r\n        return this._useInstancing;\r\n    }\r\n\r\n    public set useInstancing(use: boolean) {\r\n        if (this._useInstancing === use) {\r\n            return;\r\n        }\r\n\r\n        if (!use) {\r\n            if (this.indirectDrawBuffer) {\r\n                this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            }\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        } else {\r\n            this.indirectDrawBuffer = this._bufferManager.createRawBuffer(\r\n                20,\r\n                WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect | WebGPUConstants.BufferUsage.Storage,\r\n                undefined,\r\n                \"IndirectDrawBuffer\"\r\n            );\r\n            this._indirectDrawData = new Uint32Array(5);\r\n            this._indirectDrawData[3] = 0;\r\n            this._indirectDrawData[4] = 0;\r\n        }\r\n\r\n        this._useInstancing = use;\r\n        this._currentInstanceCount = -1;\r\n    }\r\n\r\n    constructor(bufferManager: WebGPUBufferManager) {\r\n        this._bufferManager = bufferManager;\r\n        this.uniqueId = WebGPUDrawContext._Counter++;\r\n        this._useInstancing = false;\r\n        this._currentInstanceCount = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.buffers = {};\r\n        this._isDirty = true;\r\n        this._materialContextUpdateId = 0;\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n    }\r\n\r\n    public setBuffer(name: string, buffer: Nullable<WebGPUDataBuffer>): void {\r\n        this._isDirty ||= buffer?.uniqueId !== this.buffers[name]?.uniqueId;\r\n\r\n        this.buffers[name] = buffer;\r\n    }\r\n\r\n    public setIndirectData(indexOrVertexCount: number, instanceCount: number, firstIndexOrVertex: number): void {\r\n        if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {\r\n            // The current buffer is already up to date so do nothing\r\n            // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\r\n            // are supposed to not change during the lifetime of a draw context\r\n            return;\r\n        }\r\n        this._currentInstanceCount = instanceCount;\r\n\r\n        this._indirectDrawData![0] = indexOrVertexCount;\r\n        this._indirectDrawData![1] = instanceCount;\r\n        this._indirectDrawData![2] = firstIndexOrVertex;\r\n\r\n        this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        }\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this.buffers = undefined as any;\r\n    }\r\n}\r\n","import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\n/**\r\n * Nothing specific to WebGPU in this class, but the spec is not final yet so let's remove it later on\r\n * if it is not needed\r\n * @internal\r\n **/\r\nexport class WebGPUExternalTexture extends ExternalTexture {\r\n    public constructor(video: HTMLVideoElement) {\r\n        super(video);\r\n    }\r\n}\r\n","/* eslint-disable jsdoc/require-jsdoc */\r\n/* eslint-disable babylonjs/available */\r\nimport type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Nullable } from \"../../types\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\n/** @internal */\r\nexport class WebGPUHardwareTexture implements HardwareTextureWrapper {\r\n    /**\r\n     * Cache of RenderPassDescriptor and BindGroup used when generating mipmaps (see WebGPUTextureHelper.generateMipmaps)\r\n     * @internal\r\n     */\r\n    public _mipmapGenRenderPassDescr: GPURenderPassDescriptor[][];\r\n    /** @internal */\r\n    public _mipmapGenBindGroup: GPUBindGroup[][];\r\n\r\n    /**\r\n     * Cache for the invertYPreMultiplyAlpha function (see WebGPUTextureHelper)\r\n     * @internal\r\n     */\r\n    public _copyInvertYTempTexture?: GPUTexture;\r\n    /** @internal */\r\n    public _copyInvertYRenderPassDescr: GPURenderPassDescriptor;\r\n    /** @internal */\r\n    public _copyInvertYBindGroup: GPUBindGroup;\r\n    /** @internal */\r\n    public _copyInvertYBindGroupWithOfst: GPUBindGroup;\r\n\r\n    /** @internal */\r\n    public _originalFormatIsRGB = false;\r\n\r\n    private _webgpuTexture: Nullable<GPUTexture>;\r\n    // There can be multiple MSAA textures for a single WebGPU texture because different layers of a 2DArrayTexture / 3DTexture\r\n    // or different faces of a cube texture can be bound to different render targets at the same time (in a multi RenderTargetWrapper)\r\n    private _webgpuMSAATexture: Nullable<GPUTexture[]>;\r\n\r\n    public get underlyingResource(): Nullable<GPUTexture> {\r\n        return this._webgpuTexture;\r\n    }\r\n\r\n    public getMSAATexture(index = 0): Nullable<GPUTexture> {\r\n        return this._webgpuMSAATexture?.[index] ?? null;\r\n    }\r\n\r\n    public setMSAATexture(texture: GPUTexture, index = -1) {\r\n        if (!this._webgpuMSAATexture) {\r\n            this._webgpuMSAATexture = [];\r\n        }\r\n\r\n        if (index === -1) {\r\n            index = this._webgpuMSAATexture.length;\r\n        }\r\n\r\n        this._webgpuMSAATexture![index] = texture;\r\n    }\r\n\r\n    public releaseMSAATexture() {\r\n        if (this._webgpuMSAATexture) {\r\n            for (const texture of this._webgpuMSAATexture) {\r\n                texture?.destroy();\r\n            }\r\n            this._webgpuMSAATexture = null;\r\n        }\r\n    }\r\n\r\n    public view: Nullable<GPUTextureView>;\r\n    public viewForWriting: Nullable<GPUTextureView>;\r\n    public format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    public textureUsages = 0;\r\n    public textureAdditionalUsages = 0;\r\n\r\n    constructor(existingTexture: Nullable<GPUTexture> = null) {\r\n        this._webgpuTexture = existingTexture;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public set(hardwareTexture: GPUTexture): void {\r\n        this._webgpuTexture = hardwareTexture;\r\n    }\r\n\r\n    public setUsage(_textureSource: number, generateMipMaps: boolean, is2DArray: boolean, isCube: boolean, is3D: boolean, width: number, height: number, depth: number): void {\r\n        let viewDimension: GPUTextureViewDimension = WebGPUConstants.TextureViewDimension.E2d;\r\n        let arrayLayerCount = 1;\r\n        if (isCube) {\r\n            viewDimension = is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n            arrayLayerCount = 6 * (depth || 1);\r\n        } else if (is3D) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E3d;\r\n            arrayLayerCount = 1;\r\n        } else if (is2DArray) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E2dArray;\r\n            arrayLayerCount = depth;\r\n        }\r\n\r\n        const format = WebGPUTextureHelper.GetDepthFormatOnly(this.format);\r\n        const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(this.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n\r\n        this.createView({\r\n            label: `TextureView${is3D ? \"3D\" : isCube ? \"Cube\" : \"2D\"}${is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${generateMipMaps ? \"wmips\" : \"womips\"}_${\r\n                this.format\r\n            }_${viewDimension}`,\r\n            format,\r\n            dimension: viewDimension,\r\n            mipLevelCount: generateMipMaps ? Scalar.ILog2(Math.max(width, height)) + 1 : 1,\r\n            baseArrayLayer: 0,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount,\r\n            aspect,\r\n        });\r\n    }\r\n\r\n    public createView(descriptor?: GPUTextureViewDescriptor, createViewForWriting = false): void {\r\n        this.view = this._webgpuTexture!.createView(descriptor);\r\n        if (createViewForWriting && descriptor) {\r\n            const saveNumMipMaps = descriptor.mipLevelCount;\r\n            descriptor.mipLevelCount = 1;\r\n            this.viewForWriting = this._webgpuTexture!.createView(descriptor);\r\n            descriptor.mipLevelCount = saveNumMipMaps;\r\n        }\r\n    }\r\n\r\n    public reset(): void {\r\n        this._webgpuTexture = null;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public release(): void {\r\n        this._webgpuTexture?.destroy();\r\n        this.releaseMSAATexture();\r\n        this._copyInvertYTempTexture?.destroy();\r\n        this.reset();\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatOrDepthTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    // The texture state is a bitfield where each bit is set if the texture is a float32 texture (calculated in @WebGPUEngine._draw).\r\n    // Float32 textures must be handled differently because float filtering may not be supported by the underlying browser implementation.\r\n    // In this case, we must configure the sampler as \"non filtering\", as well as set the texture sample type to \"unfilterable-float\" when creating the bind group layout.\r\n    // When that happens, we end up with different bind group layouts (depending on which type of textures have been set in the material), that we must all store\r\n    // in the WebGPUPipelineContext (see @WebGPUPipelineContext.bindGroupLayouts) for later retrieval in the bind group cache implementation (see @WebGPUCacheBindGroups.getBindGroups), thanks to this property.\r\n    // There's the same problem with depth textures, where \"float\" filtering is not supported either.\r\n    public textureState: number;\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatOrDepthTextures() {\r\n        return this._numFloatOrDepthTextures > 0;\r\n    }\r\n\r\n    protected _numFloatOrDepthTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.textureState = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatOrDepthTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatOrDepthTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatOrDepthTexture) {\r\n            this._numFloatOrDepthTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatOrDepthTexture =\r\n                texture.type === Constants.TEXTURETYPE_FLOAT ||\r\n                (texture.format >= Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 && texture.format <= Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatOrDepthTexture) {\r\n                this._numFloatOrDepthTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatOrDepthTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\n\r\n/** @internal */\r\nexport class WebGPUOcclusionQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _currentTotalIndices: number;\r\n    private _countIncrement: number;\r\n    private _querySet: WebGPUQuerySet;\r\n    private _availableIndices: number[] = [];\r\n    private _lastBuffer: Nullable<BigUint64Array>;\r\n    private _frameLastBuffer: number;\r\n    private _frameQuerySetIsDirty = -1;\r\n    private _queryFrameId: number[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet.querySet;\r\n    }\r\n\r\n    public get hasQueries(): boolean {\r\n        return this._currentTotalIndices !== this._availableIndices.length;\r\n    }\r\n\r\n    public canBeginQuery(index: number): boolean {\r\n        if (this._frameQuerySetIsDirty === this._engine.frameId || this._queryFrameId[index] === this._engine.frameId) {\r\n            return false;\r\n        }\r\n\r\n        const canBegin = this._engine._getCurrentRenderPassWrapper().renderPassDescriptor!.occlusionQuerySet !== undefined;\r\n\r\n        if (canBegin) {\r\n            this._queryFrameId[index] = this._engine.frameId;\r\n        }\r\n\r\n        return canBegin;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, startCount = 50, incrementCount = 100) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        this._frameLastBuffer = -1;\r\n        this._currentTotalIndices = 0;\r\n        this._countIncrement = incrementCount;\r\n\r\n        this._allocateNewIndices(startCount);\r\n    }\r\n\r\n    public createQuery(): number {\r\n        if (this._availableIndices.length === 0) {\r\n            this._allocateNewIndices();\r\n        }\r\n\r\n        const index = this._availableIndices[this._availableIndices.length - 1];\r\n        this._availableIndices.length--;\r\n\r\n        return index;\r\n    }\r\n\r\n    public deleteQuery(index: number): void {\r\n        this._availableIndices[this._availableIndices.length] = index;\r\n    }\r\n\r\n    public isQueryResultAvailable(index: number): boolean {\r\n        this._retrieveQueryBuffer();\r\n\r\n        return !!this._lastBuffer && index < this._lastBuffer.length;\r\n    }\r\n\r\n    public getQueryResult(index: number): number {\r\n        return Number(this._lastBuffer?.[index] ?? -1);\r\n    }\r\n\r\n    private _retrieveQueryBuffer(): void {\r\n        if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {\r\n            return;\r\n        }\r\n\r\n        if (this._frameLastBuffer !== this._engine.frameId) {\r\n            this._frameLastBuffer = this._engine.frameId;\r\n            this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {\r\n                this._lastBuffer = arrayBuffer;\r\n            });\r\n        }\r\n    }\r\n\r\n    private _allocateNewIndices(numIndices?: number): void {\r\n        numIndices = numIndices ?? this._countIncrement;\r\n\r\n        this._delayQuerySetDispose();\r\n\r\n        for (let i = 0; i < numIndices; ++i) {\r\n            this._availableIndices.push(this._currentTotalIndices + i);\r\n        }\r\n\r\n        this._currentTotalIndices += numIndices;\r\n        this._querySet = new WebGPUQuerySet(\r\n            this._engine,\r\n            this._currentTotalIndices,\r\n            WebGPUConstants.QueryType.Occlusion,\r\n            this._device,\r\n            this._bufferManager,\r\n            false,\r\n            \"QuerySet_OcclusionQuery_count_\" + this._currentTotalIndices\r\n        );\r\n\r\n        this._frameQuerySetIsDirty = this._engine.frameId;\r\n    }\r\n\r\n    private _delayQuerySetDispose(): void {\r\n        const querySet = this._querySet;\r\n        if (querySet) {\r\n            // Wait a bit before disposing of the queryset, in case some queries are still running for it\r\n            setTimeout(() => querySet.dispose, 1000);\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._querySet?.dispose();\r\n        this._availableIndices.length = 0;\r\n    }\r\n}\r\n","import { PerfCounter } from \"../../Misc/perfCounter\";\r\n\r\n/**\r\n * Class used to define a WebGPU performance counter\r\n */\r\nexport class WebGPUPerfCounter {\r\n    private _gpuTimeInFrameId = -1;\r\n\r\n    /**\r\n     * The GPU time in nanoseconds spent in the last frame\r\n     */\r\n    public counter = new PerfCounter();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addDuration(currentFrameId: number, duration: number) {\r\n        if (currentFrameId < this._gpuTimeInFrameId) {\r\n            return;\r\n        }\r\n        if (this._gpuTimeInFrameId !== currentFrameId) {\r\n            this.counter._fetchResult();\r\n            this.counter.fetchNewFrame();\r\n            this.counter.addCount(duration, false);\r\n            this._gpuTimeInFrameId = currentFrameId;\r\n        } else {\r\n            this.counter.addCount(duration, false);\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport interface IWebGPURenderPipelineStageDescriptor {\r\n    vertexStage: GPUProgrammableStage;\r\n    fragmentStage?: GPUProgrammableStage;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUPipelineContext implements IPipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public shaderProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected _leftOverUniformsByName: { [name: string]: string };\r\n\r\n    // Property used to handle vertex buffers with int values when the shader code expect float values.\r\n    public vertexBufferKindToType: { [kind: string]: number };\r\n\r\n    public sources: {\r\n        vertex: string;\r\n        fragment: string;\r\n        rawVertex: string;\r\n        rawFragment: string;\r\n    };\r\n\r\n    public stages: Nullable<IWebGPURenderPipelineStageDescriptor>;\r\n\r\n    // The field is indexed by textureState. See @WebGPUMaterialContext.textureState for more information.\r\n    public bindGroupLayouts: { [textureState: number]: GPUBindGroupLayout[] } = {};\r\n\r\n    /**\r\n     * Stores the left-over uniform buffer\r\n     */\r\n    public uniformBuffer: Nullable<UniformBuffer>;\r\n\r\n    // Default implementation.\r\n    public onCompiled?: () => void;\r\n\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.stages) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(shaderProcessingContext: WebGPUShaderProcessingContext, engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.shaderProcessingContext = shaderProcessingContext;\r\n        this._leftOverUniformsByName = {};\r\n        this.engine = engine;\r\n        this.vertexBufferKindToType = {};\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(): void {\r\n        // Nothing to do yet for spector.\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n\r\n        if (engine._doNotHandleContextLost) {\r\n            effect._fragmentSourceCode = \"\";\r\n            effect._vertexSourceCode = \"\";\r\n        }\r\n\r\n        const foundSamplers = this.shaderProcessingContext.availableTextures;\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const name = samplerList[index];\r\n            const sampler = foundSamplers[samplerList[index]];\r\n\r\n            if (sampler == null || sampler == undefined) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            } else {\r\n                samplers[name] = index;\r\n            }\r\n        }\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n\r\n        // Build the uniform layout for the left over uniforms.\r\n        this.buildUniformLayout();\r\n\r\n        const attributeNamesFromEffect: string[] = [];\r\n        const attributeLocationsFromEffect: number[] = [];\r\n        for (index = 0; index < attributesNames.length; index++) {\r\n            const location = attributes[index];\r\n            if (location >= 0) {\r\n                attributeNamesFromEffect.push(attributesNames[index]);\r\n                attributeLocationsFromEffect.push(location);\r\n            }\r\n        }\r\n        this.shaderProcessingContext.attributeNamesFromEffect = attributeNamesFromEffect;\r\n        this.shaderProcessingContext.attributeLocationsFromEffect = attributeLocationsFromEffect;\r\n    }\r\n\r\n    /** @internal */\r\n    /**\r\n     * Build the uniform buffer used in the material.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        if (!this.shaderProcessingContext.leftOverUniforms.length) {\r\n            return;\r\n        }\r\n\r\n        this.uniformBuffer = new UniformBuffer(this.engine, undefined, undefined, \"leftOver-\" + this._name);\r\n\r\n        for (const leftOverUniform of this.shaderProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n            this.uniformBuffer.addUniform(leftOverUniform.name, size, leftOverUniform.length);\r\n            this._leftOverUniformsByName[leftOverUniform.name] = leftOverUniform.type;\r\n        }\r\n\r\n        this.uniformBuffer.create();\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as WebGPUEngine;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this.uniformBuffer) {\r\n            this.uniformBuffer.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrices(uniformName, matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix3x3(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix2x2(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        this.setFloat2(uniformName, vector2.x, vector2.y);\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        this.setFloat3(uniformName, color3.r, color3.g, color3.b);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.sources?.vertex;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.sources?.fragment;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { QueryType } from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUQuerySet {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _count: number;\r\n    private _canUseMultipleBuffers: boolean;\r\n    private _querySet: GPUQuerySet;\r\n    private _queryBuffer: GPUBuffer;\r\n    private _dstBuffers: GPUBuffer[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, count: number, type: QueryType, device: GPUDevice, bufferManager: WebGPUBufferManager, canUseMultipleBuffers = true, label?: string) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n        this._count = count;\r\n        this._canUseMultipleBuffers = canUseMultipleBuffers;\r\n\r\n        this._querySet = device.createQuerySet({\r\n            label: label ?? \"QuerySet\",\r\n            type,\r\n            count,\r\n        });\r\n\r\n        this._queryBuffer = bufferManager.createRawBuffer(8 * count, WebGPUConstants.BufferUsage.QueryResolve | WebGPUConstants.BufferUsage.CopySrc, undefined, \"QueryBuffer\");\r\n\r\n        if (!canUseMultipleBuffers) {\r\n            this._dstBuffers.push(\r\n                this._bufferManager.createRawBuffer(\r\n                    8 * this._count,\r\n                    WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                    undefined,\r\n                    \"QueryBufferNoMultipleBuffers\"\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getBuffer(firstQuery: number, queryCount: number): GPUBuffer | null {\r\n        if (!this._canUseMultipleBuffers && this._dstBuffers.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const encoderResult = this._device.createCommandEncoder();\r\n\r\n        let buffer: GPUBuffer;\r\n        if (this._dstBuffers.length === 0) {\r\n            buffer = this._bufferManager.createRawBuffer(\r\n                8 * this._count,\r\n                WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                undefined,\r\n                \"QueryBufferAdditionalBuffer\"\r\n            );\r\n        } else {\r\n            buffer = this._dstBuffers[this._dstBuffers.length - 1];\r\n            this._dstBuffers.length--;\r\n        }\r\n\r\n        encoderResult.resolveQuerySet(this._querySet, firstQuery, queryCount, this._queryBuffer, 0);\r\n        encoderResult.copyBufferToBuffer(this._queryBuffer, 0, buffer, 0, 8 * queryCount);\r\n\r\n        this._device.queue.submit([encoderResult.finish()]);\r\n\r\n        return buffer;\r\n    }\r\n\r\n    public async readValues(firstQuery = 0, queryCount = 1): Promise<BigUint64Array | null> {\r\n        const buffer = this._getBuffer(firstQuery, queryCount);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        return buffer.mapAsync(WebGPUConstants.MapMode.Read).then(\r\n            () => {\r\n                const arrayBuf = new BigUint64Array(buffer.getMappedRange()).slice();\r\n\r\n                buffer.unmap();\r\n\r\n                this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n                return arrayBuf;\r\n            },\r\n            (err) => {\r\n                if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                    // Engine disposed or context loss/restoration\r\n                    return null;\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n    }\r\n\r\n    public async readValue(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 1);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        return buffer.mapAsync(WebGPUConstants.MapMode.Read).then(\r\n            () => {\r\n                const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n                const value = Number(arrayBuf[0]);\r\n\r\n                buffer.unmap();\r\n\r\n                this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n                return value;\r\n            },\r\n            (err) => {\r\n                if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                    // Engine disposed or context loss/restoration\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n    }\r\n\r\n    public async readTwoValuesAndSubtract(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 2);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        return buffer.mapAsync(WebGPUConstants.MapMode.Read).then(\r\n            () => {\r\n                const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n                const value = Number(arrayBuf[1] - arrayBuf[0]);\r\n\r\n                buffer.unmap();\r\n\r\n                this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n                return value;\r\n            },\r\n            (err) => {\r\n                if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                    // Engine disposed or context loss/restoration\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.destroy();\r\n        this._bufferManager.releaseBuffer(this._queryBuffer);\r\n        for (let i = 0; i < this._dstBuffers.length; ++i) {\r\n            this._bufferManager.releaseBuffer(this._dstBuffers[i]);\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\n\r\nconst _maxGroups = 4;\r\nconst _maxBindingsPerGroup = 1 << 16;\r\n\r\n// all types not listed are assumed to consume 1 location\r\nconst _typeToLocationSize: { [key: string]: number } = {\r\n    // GLSL types\r\n    mat2: 2,\r\n    mat3: 3,\r\n    mat4: 4,\r\n\r\n    // WGSL types\r\n    mat2x2: 2,\r\n    mat3x3: 3,\r\n    mat4x4: 4,\r\n};\r\n\r\n/** @internal */\r\nexport interface WebGPUBindingInfo {\r\n    groupIndex: number;\r\n    bindingIndex: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUTextureDescription {\r\n    autoBindSampler?: boolean;\r\n    isTextureArray: boolean;\r\n    isStorageTexture: boolean;\r\n    textures: Array<WebGPUBindingInfo>;\r\n    sampleType?: GPUTextureSampleType; // not used if the texture is a storage texture\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUSamplerDescription {\r\n    binding: WebGPUBindingInfo;\r\n    type: GPUSamplerBindingType;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBufferDescription {\r\n    binding: WebGPUBindingInfo;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBindGroupLayoutEntryInfo {\r\n    name: string;\r\n    index: number; // index of the entry (GPUBindGroupLayoutEntry) in the bindGroupLayoutEntries[group] array\r\n    nameInArrayOfTexture?: string; // something like texture0, texture1, ... if texture is an array, else same thing as \"name\"\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class WebGPUShaderProcessingContext implements ShaderProcessingContext {\r\n    /** @internal */\r\n    public static _SimplifiedKnownBindings = true; // if true, use only group=0,binding=0 as a known group/binding for the Scene ubo and use group=1,binding=X for all other bindings\r\n    // if false, see _KnownUBOs for the known groups/bindings used\r\n\r\n    protected static _SimplifiedKnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n        Light0: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light1: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light2: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light3: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light4: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light5: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light6: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light7: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light8: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light9: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light10: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light11: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light12: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light13: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light14: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light15: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light16: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light17: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light18: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light19: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light20: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light21: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light22: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light23: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light24: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light25: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light26: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light27: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light28: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light29: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light30: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light31: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Material: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Mesh: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Internals: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n    };\r\n\r\n    protected static _KnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n\r\n        Light0: { binding: { groupIndex: 1, bindingIndex: 0 } },\r\n        Light1: { binding: { groupIndex: 1, bindingIndex: 1 } },\r\n        Light2: { binding: { groupIndex: 1, bindingIndex: 2 } },\r\n        Light3: { binding: { groupIndex: 1, bindingIndex: 3 } },\r\n        Light4: { binding: { groupIndex: 1, bindingIndex: 4 } },\r\n        Light5: { binding: { groupIndex: 1, bindingIndex: 5 } },\r\n        Light6: { binding: { groupIndex: 1, bindingIndex: 6 } },\r\n        Light7: { binding: { groupIndex: 1, bindingIndex: 7 } },\r\n        Light8: { binding: { groupIndex: 1, bindingIndex: 8 } },\r\n        Light9: { binding: { groupIndex: 1, bindingIndex: 9 } },\r\n        Light10: { binding: { groupIndex: 1, bindingIndex: 10 } },\r\n        Light11: { binding: { groupIndex: 1, bindingIndex: 11 } },\r\n        Light12: { binding: { groupIndex: 1, bindingIndex: 12 } },\r\n        Light13: { binding: { groupIndex: 1, bindingIndex: 13 } },\r\n        Light14: { binding: { groupIndex: 1, bindingIndex: 14 } },\r\n        Light15: { binding: { groupIndex: 1, bindingIndex: 15 } },\r\n        Light16: { binding: { groupIndex: 1, bindingIndex: 16 } },\r\n        Light17: { binding: { groupIndex: 1, bindingIndex: 17 } },\r\n        Light18: { binding: { groupIndex: 1, bindingIndex: 18 } },\r\n        Light19: { binding: { groupIndex: 1, bindingIndex: 19 } },\r\n        Light20: { binding: { groupIndex: 1, bindingIndex: 20 } },\r\n        Light21: { binding: { groupIndex: 1, bindingIndex: 21 } },\r\n        Light22: { binding: { groupIndex: 1, bindingIndex: 22 } },\r\n        Light23: { binding: { groupIndex: 1, bindingIndex: 23 } },\r\n        Light24: { binding: { groupIndex: 1, bindingIndex: 24 } },\r\n        Light25: { binding: { groupIndex: 1, bindingIndex: 25 } },\r\n        Light26: { binding: { groupIndex: 1, bindingIndex: 26 } },\r\n        Light27: { binding: { groupIndex: 1, bindingIndex: 27 } },\r\n        Light28: { binding: { groupIndex: 1, bindingIndex: 28 } },\r\n        Light29: { binding: { groupIndex: 1, bindingIndex: 29 } },\r\n        Light30: { binding: { groupIndex: 1, bindingIndex: 30 } },\r\n        Light31: { binding: { groupIndex: 1, bindingIndex: 31 } },\r\n\r\n        Material: { binding: { groupIndex: 2, bindingIndex: 0 } },\r\n        Mesh: { binding: { groupIndex: 2, bindingIndex: 1 } },\r\n        Internals: { binding: { groupIndex: 2, bindingIndex: 2 } },\r\n    };\r\n\r\n    public static get KnownUBOs() {\r\n        return WebGPUShaderProcessingContext._SimplifiedKnownBindings ? WebGPUShaderProcessingContext._SimplifiedKnownUBOs : WebGPUShaderProcessingContext._KnownUBOs;\r\n    }\r\n\r\n    public shaderLanguage: ShaderLanguage;\r\n\r\n    public uboNextBindingIndex: number;\r\n    public freeGroupIndex: number;\r\n    public freeBindingIndex: number;\r\n\r\n    public availableVaryings: { [key: string]: number };\r\n    public availableAttributes: { [key: string]: number };\r\n    public availableBuffers: { [key: string]: WebGPUBufferDescription };\r\n    public availableTextures: { [key: string]: WebGPUTextureDescription };\r\n    public availableSamplers: { [key: string]: WebGPUSamplerDescription };\r\n\r\n    public leftOverUniforms: { name: string; type: string; length: number }[];\r\n\r\n    public orderedAttributes: string[];\r\n    public bindGroupLayoutEntries: GPUBindGroupLayoutEntry[][];\r\n    public bindGroupLayoutEntryInfo: WebGPUBindGroupLayoutEntryInfo[][];\r\n    public bindGroupEntries: GPUBindGroupEntry[][];\r\n    public bufferNames: string[]; // list of all uniform/storage buffer names used in the shader\r\n    public textureNames: string[]; // list of all texture names used in the shader\r\n    public samplerNames: string[]; // list of all sampler names used in the shader\r\n    public attributeNamesFromEffect: string[];\r\n    public attributeLocationsFromEffect: number[];\r\n\r\n    public vertexBufferKindToNumberOfComponents: { [kind: string]: number } = {};\r\n\r\n    private _attributeNextLocation: number;\r\n    private _varyingNextLocation: number;\r\n\r\n    constructor(shaderLanguage: ShaderLanguage, pureMode = false) {\r\n        this.shaderLanguage = shaderLanguage;\r\n\r\n        this._attributeNextLocation = 0;\r\n        this._varyingNextLocation = 0;\r\n        this.freeGroupIndex = 0;\r\n        this.freeBindingIndex = 0;\r\n\r\n        this.availableVaryings = {};\r\n        this.availableAttributes = {};\r\n        this.availableBuffers = {};\r\n        this.availableTextures = {};\r\n        this.availableSamplers = {};\r\n\r\n        this.orderedAttributes = [];\r\n        this.bindGroupLayoutEntries = [];\r\n        this.bindGroupLayoutEntryInfo = [];\r\n        this.bindGroupEntries = [];\r\n        this.bufferNames = [];\r\n        this.textureNames = [];\r\n        this.samplerNames = [];\r\n\r\n        this.leftOverUniforms = [];\r\n\r\n        if (!pureMode) {\r\n            this._findStartingGroupBinding();\r\n        }\r\n    }\r\n\r\n    private _findStartingGroupBinding(): void {\r\n        const knownUBOs = WebGPUShaderProcessingContext.KnownUBOs;\r\n\r\n        const groups: number[] = [];\r\n        for (const name in knownUBOs) {\r\n            const binding = knownUBOs[name].binding;\r\n            if (binding.groupIndex === -1) {\r\n                continue;\r\n            }\r\n            if (groups[binding.groupIndex] === undefined) {\r\n                groups[binding.groupIndex] = binding.bindingIndex;\r\n            } else {\r\n                groups[binding.groupIndex] = Math.max(groups[binding.groupIndex], binding.bindingIndex);\r\n            }\r\n        }\r\n\r\n        this.freeGroupIndex = groups.length - 1;\r\n        if (this.freeGroupIndex === 0) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        } else {\r\n            this.freeBindingIndex = groups[groups.length - 1] + 1;\r\n        }\r\n    }\r\n\r\n    public getAttributeNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._attributeNextLocation;\r\n\r\n        this._attributeNextLocation += (_typeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getVaryingNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._varyingNextLocation;\r\n\r\n        this._varyingNextLocation += (_typeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getNextFreeUBOBinding() {\r\n        return this._getNextFreeBinding(1);\r\n    }\r\n\r\n    private _getNextFreeBinding(bindingCount: number) {\r\n        if (this.freeBindingIndex > _maxBindingsPerGroup - bindingCount) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        }\r\n\r\n        if (this.freeGroupIndex === _maxGroups) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Too many textures or UBOs have been declared and it is not supported in WebGPU.\";\r\n        }\r\n\r\n        const returnValue = {\r\n            groupIndex: this.freeGroupIndex,\r\n            bindingIndex: this.freeBindingIndex,\r\n        };\r\n\r\n        this.freeBindingIndex += bindingCount;\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IShaderProcessor } from \"../Processors/iShaderProcessor\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUSamplerDescription, WebGPUShaderProcessingContext, WebGPUTextureDescription, WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\n\r\n/** @internal */\r\nexport abstract class WebGPUShaderProcessor implements IShaderProcessor {\r\n    public static readonly LeftOvertUBOName = \"LeftOver\";\r\n    public static readonly InternalsUBOName = \"Internals\";\r\n\r\n    public static UniformSizes: { [type: string]: number } = {\r\n        // GLSL types\r\n        bool: 1,\r\n        int: 1,\r\n        float: 1,\r\n        vec2: 2,\r\n        ivec2: 2,\r\n        uvec2: 2,\r\n        vec3: 3,\r\n        ivec3: 3,\r\n        uvec3: 3,\r\n        vec4: 4,\r\n        ivec4: 4,\r\n        uvec4: 4,\r\n        mat2: 4,\r\n        mat3: 12,\r\n        mat4: 16,\r\n\r\n        // WGSL types\r\n        i32: 1,\r\n        u32: 1,\r\n        f32: 1,\r\n        mat2x2: 4,\r\n        mat3x3: 12,\r\n        mat4x4: 16,\r\n        mat2x2f: 4,\r\n        mat3x3f: 12,\r\n        mat4x4f: 16,\r\n        vec2i: 2,\r\n        vec3i: 3,\r\n        vec4i: 4,\r\n        vec2u: 2,\r\n        vec3u: 3,\r\n        vec4u: 4,\r\n        vec2f: 2,\r\n        vec3f: 3,\r\n        vec4f: 4,\r\n        vec2h: 1,\r\n        vec3h: 2,\r\n        vec4h: 2,\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerFunctionByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"sampler2D\",\r\n        sampler2DArray: \"sampler2DArray\",\r\n        sampler2DShadow: \"sampler2DShadow\",\r\n        sampler2DArrayShadow: \"sampler2DArrayShadow\",\r\n        samplerCube: \"samplerCube\",\r\n        sampler3D: \"sampler3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _TextureTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"texture2D\",\r\n        sampler2DArray: \"texture2DArray\",\r\n        sampler2DShadow: \"texture2D\",\r\n        sampler2DArrayShadow: \"texture2DArray\",\r\n        samplerCube: \"textureCube\",\r\n        samplerCubeArray: \"textureCubeArray\",\r\n        sampler3D: \"texture3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _GpuTextureViewDimensionByWebGPUTextureType: { [key: string]: GPUTextureViewDimension } = {\r\n        textureCube: WebGPUConstants.TextureViewDimension.Cube,\r\n        textureCubeArray: WebGPUConstants.TextureViewDimension.CubeArray,\r\n        texture2D: WebGPUConstants.TextureViewDimension.E2d,\r\n        texture2DArray: WebGPUConstants.TextureViewDimension.E2dArray,\r\n        texture3D: WebGPUConstants.TextureViewDimension.E3d,\r\n    };\r\n\r\n    // if the webgl sampler type is not listed in this array, \"sampler\" is taken by default\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2DShadow: \"samplerShadow\",\r\n        sampler2DArrayShadow: \"samplerShadow\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _IsComparisonSamplerByWebGPUSamplerType: { [key: string]: boolean } = {\r\n        samplerShadow: true,\r\n        samplerArrayShadow: true,\r\n        sampler: false,\r\n    };\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _webgpuProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected abstract _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number];\r\n    protected abstract _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string;\r\n\r\n    protected _addUniformToLeftOverUBO(name: string, uniformType: string, preProcessors: { [key: string]: string }): void {\r\n        let length = 0;\r\n\r\n        [name, uniformType, length] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {\r\n            if (this._webgpuProcessingContext.leftOverUniforms[i].name === name) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._webgpuProcessingContext.leftOverUniforms.push({\r\n            name,\r\n            type: uniformType,\r\n            length,\r\n        });\r\n    }\r\n\r\n    protected _buildLeftOverUBO(): string {\r\n        if (!this._webgpuProcessingContext.leftOverUniforms.length) {\r\n            return \"\";\r\n        }\r\n        const name = WebGPUShaderProcessor.LeftOvertUBOName;\r\n        let availableUBO = this._webgpuProcessingContext.availableBuffers[name];\r\n        if (!availableUBO) {\r\n            availableUBO = {\r\n                binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n            };\r\n            this._webgpuProcessingContext.availableBuffers[name] = availableUBO;\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, true);\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, false);\r\n        }\r\n\r\n        return this._generateLeftOverUBOCode(name, availableUBO);\r\n    }\r\n\r\n    protected _collectBindingNames(): void {\r\n        // collect all the binding names for faster processing in WebGPUCacheBindGroup\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n            if (setDefinition === undefined) {\r\n                this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];\r\n                continue;\r\n            }\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const name = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;\r\n                if (entry) {\r\n                    if (entry.texture || entry.externalTexture || entry.storageTexture) {\r\n                        this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture!);\r\n                    } else if (entry.sampler) {\r\n                        this._webgpuProcessingContext.samplerNames.push(name);\r\n                    } else if (entry.buffer) {\r\n                        this._webgpuProcessingContext.bufferNames.push(name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _preCreateBindGroupEntries(): void {\r\n        const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries: GPUBindGroupEntry[] = [];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: undefined as any,\r\n                    });\r\n                } else if (entry.buffer) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: {\r\n                            buffer: undefined as any,\r\n                            offset: 0,\r\n                            size: 0,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n\r\n            bindGroupEntries[i] = entries;\r\n        }\r\n    }\r\n\r\n    protected _addTextureBindingDescription(\r\n        name: string,\r\n        textureInfo: WebGPUTextureDescription,\r\n        textureIndex: number,\r\n        dimension: Nullable<GPUTextureViewDimension>,\r\n        format: Nullable<GPUTextureFormat>,\r\n        isVertex: boolean\r\n    ): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = textureInfo.textures[textureIndex];\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            let len;\r\n            if (dimension === null) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    externalTexture: {},\r\n                });\r\n            } else if (format) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    storageTexture: {\r\n                        access: WebGPUConstants.StorageTextureAccess.WriteOnly,\r\n                        format,\r\n                        viewDimension: dimension,\r\n                    },\r\n                });\r\n            } else {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    texture: {\r\n                        sampleType: textureInfo.sampleType,\r\n                        viewDimension: dimension,\r\n                        multisampled: false,\r\n                    },\r\n                });\r\n            }\r\n            const textureName = textureInfo.isTextureArray ? name + textureIndex : name;\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1, nameInArrayOfTexture: textureName };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addSamplerBindingDescription(name: string, samplerInfo: WebGPUSamplerDescription, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = samplerInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                sampler: {\r\n                    type: samplerInfo.type,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addBufferBindingDescription(name: string, uniformBufferInfo: WebGPUBufferDescription, bufferType: GPUBufferBindingType, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = uniformBufferInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                buffer: {\r\n                    type: bufferType,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport { InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { Constants } from \"../constants\";\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n    protected _vertexIsGLES3: boolean = false;\r\n    protected _fragmentIsGLES3: boolean = false;\r\n\r\n    public override shaderLanguage = ShaderLanguage.GLSL;\r\n    public parseGLES3 = true;\r\n    public attributeKeywordName: string | undefined;\r\n    public varyingVertexKeywordName: string | undefined;\r\n    public varyingFragmentKeywordName: string | undefined;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substr(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n        this.attributeKeywordName = undefined;\r\n        this.varyingVertexKeywordName = undefined;\r\n        this.varyingFragmentKeywordName = undefined;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\r\n        const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\r\n\r\n        if (isFragment) {\r\n            this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n            if (this._fragmentIsGLES3) {\r\n                this.varyingFragmentKeywordName = \"in\";\r\n            }\r\n            return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n\r\n        this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n        if (this._vertexIsGLES3) {\r\n            this.attributeKeywordName = \"in\";\r\n            this.varyingVertexKeywordName = \"out\";\r\n        }\r\n        return alreadyInjected ? code : ubDeclaration + code;\r\n    }\r\n\r\n    public varyingCheck(varying: string, isFragment: boolean) {\r\n        const outRegex = /(flat\\s)?\\s*\\bout\\b/;\r\n        const inRegex = /(flat\\s)?\\s*\\bin\\b/;\r\n        const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n        const match = regex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationQualifier = match[1] ?? \"\";\r\n            const varyingType = match[2];\r\n            const name = match[3];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(\r\n                match[0],\r\n                location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`\r\n            );\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\r\n        const match = regex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType = numComponents < 0 ? (numComponents === -1 ? \"int\" : \"ivec\" + -numComponents) : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\r\n                const newName = `_int_${name}_`;\r\n\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\r\n            } else {\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n            }\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match !== null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + Constants.AUTOSAMPLERSUFFIX;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substr(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                      ? WebGPUConstants.TextureSampleType.Uint\r\n                      : componentType === \"i\"\r\n                        ? WebGPUConstants.TextureSampleType.Sint\r\n                        : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match !== null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        defines: string[],\r\n        isFragment: boolean,\r\n        _processingContext: Nullable<ShaderProcessingContext>,\r\n        _parameters?: { [key: string]: number | string | boolean | undefined }\r\n    ): string {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord_ = gl_FragCoord;\r\n                if (yFactor_ == 1.) {\r\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\r\n            const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\r\n            if (!this._fragmentIsGLES3) {\r\n                code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            } else {\r\n                const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\r\n                if (match !== null) {\r\n                    code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\r\n                }\r\n            }\r\n            code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = InjectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor_;\\n\";\r\n            // isNDCHalfZRange is always true in WebGPU\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match !== null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments, InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport { Constants } from \"../constants\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/helperFunctions\";\r\nimport \"../../ShadersWGSL/ShadersInclude/fresnelFunction\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/decalFragment\";\r\nimport \"../../ShadersWGSL/particles.vertex\";\r\n\r\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesInputWGSL: string[];\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesConversionCodeWGSL: string[];\r\n    protected _hasNonFloatAttribute: boolean;\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public override shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n    public pureMode = false;\r\n\r\n    public preProcessor(code: string, defines: string[], preProcessors: { [key: string]: string }, isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>) {\r\n        // Convert defines into const\r\n        for (const key in preProcessors) {\r\n            if (key === \"__VERSION__\") {\r\n                continue;\r\n            }\r\n            const value = preProcessors[key];\r\n            if (!isNaN(parseInt(value)) || !isNaN(parseFloat(value))) {\r\n                code = `const ${key} = ${value};\\n` + code;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesInputWGSL = [];\r\n        this._attributesWGSL = [];\r\n        this._attributesConversionCodeWGSL = [];\r\n        this._hasNonFloatAttribute = false;\r\n        this._varyingsWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        // Same check as in webgpuShaderProcessorsGLSL to avoid same ubDelcaration to be injected twice.\r\n        const ubDeclaration = this.pureMode\r\n            ? \"\"\r\n            : `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n`;\r\n        const alreadyInjected = code.indexOf(ubDeclaration) !== -1;\r\n        return alreadyInjected ? code : ubDeclaration + RemoveComments(code);\r\n    }\r\n\r\n    public varyingCheck(varying: string): boolean {\r\n        const regex = /(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*\\bvarying\\b/;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationType = match[1] ?? \"perspective\";\r\n            const interpolationSampling = match[2] ?? \"center\";\r\n            const varyingType = match[4];\r\n            const name = match[3];\r\n            const interpolation = interpolationType === \"flat\" ? `@interpolate(${interpolationType})` : `@interpolate(${interpolationType}, ${interpolationSampling})`;\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`  @location(${location}) ${interpolation} ${name} : ${varyingType},`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType =\r\n                    numComponents < 0 ? (numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\") : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\r\n                const newName = `_int_${name}_`;\r\n\r\n                this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\r\n                this._hasNonFloatAttribute = true;\r\n            } else {\r\n                this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\r\n            }\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                  ? WebGPUConstants.TextureSampleType.Uint\r\n                  : componentType === \"i32\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    // We need to process defines which are directly in the files themselves\r\n    public postProcessor(code: string) {\r\n        const definePattern = /#define (.+?) (.+?)$/gm;\r\n\r\n        let match: RegExpExecArray | null;\r\n\r\n        while ((match = definePattern.exec(code)) !== null) {\r\n            code = code.replace(new RegExp(match[1], \"g\"), match[2]);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"fragmentInputs.position\") >= 0 && !this.pureMode\r\n                ? `\r\n            if (internals.yFactor_ == 1.) {\r\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define (\\w+)\\s+(\\d+\\.?\\d*)/g, \"const $1 = $2;\");\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesInputWGSL.length > 0) {\r\n            vertexInputs += this._attributesInputWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n            vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\r\n        }\r\n\r\n        let vertexOutputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexOutputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\r\n\r\n        vertexCode = vertexInputs + vertexOutputs + vertexCode;\r\n\r\n        let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\r\n            vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\r\n            vertexMainStartingCode += \"\\n\";\r\n        }\r\n        const vertexMainEndingCode = this.pureMode\r\n            ? `  return vertexOutputs;`\r\n            : `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\r\n        let needDiagnosticOff = vertexCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        vertexCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") +\r\n            InjectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define (\\w+)\\s+(\\d+\\.?\\d*)/g, \"const $1 = $2;\");\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        if (!this.pureMode) {\r\n            fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n        }\r\n\r\n        let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n\";\r\n\r\n        // Adding fragData output locations\r\n        let regex = /const SCENE_MRT_COUNT = (\\d+);/;\r\n        let match = fragmentCode.match(regex);\r\n        let indexLocation = 0;\r\n\r\n        if (match) {\r\n            const number = parseInt(match[1]);\r\n            if (number > 0) {\r\n                for (let index = 0; index < number; index++) {\r\n                    fragmentOutputs += ` @location(${indexLocation}) fragData${indexLocation} : vec4<f32>,\\n`;\r\n                    indexLocation++;\r\n                }\r\n                if (fragmentCode.indexOf(\"MRT_AND_COLOR\") !== -1) {\r\n                    fragmentOutputs += `  @location(${indexLocation}) color : vec4<f32>,\\n`;\r\n                    indexLocation++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Adding fragData output locations\r\n        regex = /oitDepthSampler/;\r\n        match = fragmentCode.match(regex);\r\n\r\n        if (match) {\r\n            fragmentOutputs += ` @location(${indexLocation++}) depth : vec2<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) frontColor : vec4<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) backColor : vec4<f32>,\\n`;\r\n        }\r\n\r\n        if (indexLocation === 0) {\r\n            fragmentOutputs += \"  @location(0) color : vec4<f32>,\\n\";\r\n            indexLocation++;\r\n        }\r\n\r\n        // FragDepth\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\r\n\r\n        fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\r\n\r\n        const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\r\n        const fragmentEndingCode = \"  return fragmentOutputs;\";\r\n        needDiagnosticOff = fragmentCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        fragmentCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") + InjectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const suffixLessLength = name.length - Constants.AUTOSAMPLERSUFFIX.length;\r\n            const textureName = name.lastIndexOf(Constants.AUTOSAMPLERSUFFIX) === suffixLessLength ? name.substring(0, suffixLessLength) : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.availableBuffers[name]?.binding;\r\n                        if (!binding) {\r\n                            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                        }\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                      ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                      : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*?)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBundleList } from \"./webgpuBundleList\";\r\n\r\n/** @internal */\r\nexport class WebGPUSnapshotRendering {\r\n    private _engine: WebGPUEngine;\r\n\r\n    private _record = false;\r\n    private _play = false;\r\n    private _playBundleListIndex = 0;\r\n    private _allBundleLists: WebGPUBundleList[] = [];\r\n    private _modeSaved: number;\r\n    private _bundleList: WebGPUBundleList;\r\n\r\n    private _enabled = false;\r\n    private _mode: number;\r\n\r\n    constructor(engine: WebGPUEngine, renderingMode: number, bundleList: WebGPUBundleList) {\r\n        this._engine = engine;\r\n        this._mode = renderingMode;\r\n        this._bundleList = bundleList;\r\n    }\r\n\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public get play() {\r\n        return this._play;\r\n    }\r\n\r\n    public get record() {\r\n        return this._record;\r\n    }\r\n\r\n    public set enabled(activate: boolean) {\r\n        this._allBundleLists.length = 0;\r\n        this._record = this._enabled = activate;\r\n        this._play = false;\r\n        if (activate) {\r\n            this._modeSaved = this._mode;\r\n            this._mode = Constants.SNAPSHOTRENDERING_STANDARD; // need to reset to standard for the recording pass to avoid some code being bypassed\r\n        }\r\n    }\r\n\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(mode: number) {\r\n        if (this._record) {\r\n            this._modeSaved = mode;\r\n        } else {\r\n            this._mode = mode;\r\n        }\r\n    }\r\n\r\n    public endRenderPass(currentRenderPass: GPURenderPassEncoder): boolean {\r\n        if (!this._record && !this._play) {\r\n            // Snapshot rendering mode is not enabled\r\n            return false;\r\n        }\r\n\r\n        let bundleList: WebGPUBundleList;\r\n\r\n        if (this._record) {\r\n            bundleList = this._bundleList.clone();\r\n            this._allBundleLists.push(bundleList);\r\n            this._bundleList.reset();\r\n        } else {\r\n            // We are playing the snapshot\r\n            if (this._playBundleListIndex >= this._allBundleLists.length) {\r\n                throw new Error(\r\n                    `Invalid playBundleListIndex! Your snapshot is no longer valid for the current frame, you should recreate a new one. playBundleListIndex=${this._playBundleListIndex}, allBundleLists.length=${this._allBundleLists.length}}`\r\n                );\r\n            }\r\n            bundleList = this._allBundleLists[this._playBundleListIndex++];\r\n        }\r\n\r\n        bundleList.run(currentRenderPass);\r\n\r\n        if (this._mode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            this._engine._reportDrawCall(bundleList.numDrawCalls);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        if (this._record) {\r\n            // We stop recording and switch to replay mode for the next frames\r\n            this._record = false;\r\n            this._play = true;\r\n            this._mode = this._modeSaved;\r\n        }\r\n\r\n        this._playBundleListIndex = 0;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.enabled = false;\r\n        this.enabled = true;\r\n    }\r\n}\r\n","import type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { StencilStateComposer } from \"../../States/stencilStateComposer\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUStencilStateComposer extends StencilStateComposer {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public override set func(value: number) {\r\n        if (this._func === value) {\r\n            return;\r\n        }\r\n\r\n        this._func = value;\r\n        this._cache.setStencilCompare(value);\r\n    }\r\n\r\n    public override get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public override set funcMask(value: number) {\r\n        if (this._funcMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcMask = value;\r\n        this._cache.setStencilReadMask(value);\r\n    }\r\n\r\n    public override get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public override set opStencilFail(value: number) {\r\n        if (this._opStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilFail = value;\r\n        this._cache.setStencilFailOp(value);\r\n    }\r\n\r\n    public override get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public override set opDepthFail(value: number) {\r\n        if (this._opDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opDepthFail = value;\r\n        this._cache.setStencilDepthFailOp(value);\r\n    }\r\n\r\n    public override get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public override set opStencilDepthPass(value: number) {\r\n        if (this._opStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilDepthPass = value;\r\n        this._cache.setStencilPassOp(value);\r\n    }\r\n\r\n    public override get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public override set mask(value: number) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n        this._cache.setStencilWriteMask(value);\r\n    }\r\n\r\n    public override get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public override set enabled(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._cache.setStencilEnabled(value);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetStencilState();\r\n    }\r\n\r\n    public override apply() {\r\n        const stencilMaterialEnabled = this.stencilMaterial?.enabled;\r\n\r\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial!.enabled : this.stencilGlobal.enabled;\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this.func = stencilMaterialEnabled ? this.stencilMaterial!.func : this.stencilGlobal.func;\r\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial!.funcRef : this.stencilGlobal.funcRef;\r\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial!.funcMask : this.stencilGlobal.funcMask;\r\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.opStencilFail : this.stencilGlobal.opStencilFail;\r\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.opDepthFail : this.stencilGlobal.opDepthFail;\r\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\r\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial!.mask : this.stencilGlobal.mask;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Constants } from \"../constants\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\n\r\n/** @internal */\r\nexport class WebGPUTextureHelper {\r\n    public static ComputeNumMipmapLevels(width: number, height: number) {\r\n        return Scalar.ILog2(Math.max(width, height)) + 1;\r\n    }\r\n\r\n    public static GetTextureTypeFromFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            // One Component = 8 bits\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n            // One component = 16 bits\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            // One component = 32 bits\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    public static GetBlockInformationFromFormat(format: GPUTextureFormat): { width: number; height: number; length: number } {\r\n        switch (format) {\r\n            // 8 bits formats\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n                return { width: 1, height: 1, length: 1 };\r\n\r\n            // 16 bits formats\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n                return { width: 1, height: 1, length: 2 };\r\n\r\n            // 32 bits formats\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n                return { width: 1, height: 1, length: 4 };\r\n\r\n            // 64 bits formats\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return { width: 1, height: 1, length: 8 };\r\n\r\n            // 128 bits formats\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n                return { width: 1, height: 1, length: 16 };\r\n\r\n            // Depth and stencil formats\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Stencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return { width: 1, height: 1, length: 2 };\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24Plus format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24PlusStencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return { width: 1, height: 1, length: 4 };\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return { width: 1, height: 1, length: 5 };\r\n\r\n            // BC compressed formats usable if \"texture-compression-bc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n                return { width: 5, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n                return { width: 5, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n                return { width: 6, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n                return { width: 6, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n                return { width: 8, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n                return { width: 8, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n                return { width: 8, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n                return { width: 10, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n                return { width: 10, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n                return { width: 10, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n                return { width: 10, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n                return { width: 12, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return { width: 12, height: 12, length: 16 };\r\n        }\r\n\r\n        return { width: 1, height: 1, length: 4 };\r\n    }\r\n\r\n    public static IsHardwareTexture(texture: HardwareTextureWrapper | GPUTexture): texture is HardwareTextureWrapper {\r\n        return !!(texture as HardwareTextureWrapper).release;\r\n    }\r\n\r\n    public static IsInternalTexture(texture: InternalTexture | GPUTexture): texture is InternalTexture {\r\n        return !!(texture as InternalTexture).dispose;\r\n    }\r\n\r\n    public static IsImageBitmap(imageBitmap: ImageBitmap | { width: number; height: number }): imageBitmap is ImageBitmap {\r\n        return (imageBitmap as ImageBitmap).close !== undefined;\r\n    }\r\n\r\n    public static IsImageBitmapArray(imageBitmap: ImageBitmap[] | { width: number; height: number }): imageBitmap is ImageBitmap[] {\r\n        return Array.isArray(imageBitmap as ImageBitmap[]) && (imageBitmap as ImageBitmap[])[0].close !== undefined;\r\n    }\r\n\r\n    public static IsCompressedFormat(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetWebGPUTextureFormat(type: number, format: number, useSRGBBuffer = false): GPUTextureFormat {\r\n        switch (format) {\r\n            case Constants.TEXTUREFORMAT_DEPTH16:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case Constants.TEXTUREFORMAT_DEPTH24:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case Constants.TEXTUREFORMAT_DEPTH24_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth24PlusStencil8;\r\n            case Constants.TEXTUREFORMAT_DEPTH32_FLOAT:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth32FloatStencil8;\r\n            case Constants.TEXTUREFORMAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Stencil8;\r\n\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC7RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBUFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC3RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC2RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC1RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB : WebGPUConstants.TextureFormat.ASTC4x4Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGB8Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGBA8Unorm;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Snorm;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_BGRA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BGRA8UnormSRGB : WebGPUConstants.TextureFormat.BGRA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Uint;\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_ALPHA format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                }\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_INT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R32Float; // By default. Other possibility is R16Float.\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG32Float; // By default. Other possibility is RG16Float.\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float; // By default. Other possibility is RGBA16Float.\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float;\r\n                }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R16Float;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG16Float;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2UINT;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                }\r\n        }\r\n\r\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    }\r\n\r\n    public static GetNumChannelsFromWebGPUTextureFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return 1;\r\n\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return 2;\r\n\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n                return 3;\r\n\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return 4;\r\n        }\r\n\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `Unknown format ${format}!`;\r\n    }\r\n\r\n    public static HasStencilAspect(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static HasDepthAndStencilAspects(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetDepthFormatOnly(format: GPUTextureFormat): GPUTextureFormat {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n        }\r\n\r\n        return format;\r\n    }\r\n\r\n    public static GetSample(sampleCount: number) {\r\n        // WebGPU only supports 1 or 4\r\n        return sampleCount > 1 ? 4 : 1;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// License for the mipmap generation code:\r\n//\r\n// Copyright 2020 Brandon Jones\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport type { ProcessingOptions } from \"../Processors/shaderProcessingOptions\";\r\nimport { ShaderLanguage } from \"core/Materials\";\r\nimport { Finalize, Initialize, Process } from \"../Processors/shaderProcessor\";\r\nimport type { WebGPUShaderProcessorWGSL } from \"./webgpuShaderProcessorsWGSL\";\r\n\r\n// TODO WEBGPU improve mipmap generation by using compute shaders\r\n\r\nconst mipmapVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.vTex = tex[input.vertexIndex];\r\n        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst mipmapFragmentSource = `\r\n    var imgSampler: sampler;\r\n    var img: texture_2d<f32>;\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = textureSample(img, imgSampler, input.vTex);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        #ifdef INVERTY\r\n            vertexOutputs.vTextureSize = vec2f(textureDimensions(img, 0));\r\n        #endif\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(input.vTextureSize.y - input.position.y)), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        fragmentOutputs.color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n    uniform ofstX: f32;\r\n    uniform ofstY: f32;\r\n    uniform width: f32;\r\n    uniform height: f32;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        if (input.position.x < uniforms.ofstX || input.position.x >= uniforms.ofstX + uniforms.width) {\r\n            discard;\r\n        }\r\n        if (input.position.y < uniforms.ofstY || input.position.y >= uniforms.ofstY + uniforms.height) {\r\n            discard;\r\n        }\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(uniforms.ofstY + uniforms.height - (input.position.y - uniforms.ofstY))), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst clearVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst clearFragmentSource = `\r\n    uniform color: vec4f;\r\n\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = uniforms.color;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureVertexSource = `\r\n    struct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n        @location(0) fragUV : vec2<f32>\r\n    }\r\n\r\n    @vertex\r\n    fn main(\r\n        @builtin(vertex_index) VertexIndex : u32\r\n    ) -> VertexOutput {\r\n        var pos = array<vec2<f32>, 4>(\r\n            vec2(-1.0,  1.0),\r\n            vec2( 1.0,  1.0),\r\n            vec2(-1.0, -1.0),\r\n            vec2( 1.0, -1.0)\r\n        );\r\n        var tex = array<vec2<f32>, 4>(\r\n            vec2(0.0, 0.0),\r\n            vec2(1.0, 0.0),\r\n            vec2(0.0, 1.0),\r\n            vec2(1.0, 1.0)\r\n        );\r\n\r\n        var output: VertexOutput;\r\n\r\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        output.fragUV = tex[VertexIndex];\r\n\r\n        return output;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureInvertYFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\r\n    }\r\n    `;\r\n\r\nenum PipelineType {\r\n    MipMap = 0,\r\n    InvertYPremultiplyAlpha = 1,\r\n    Clear = 2,\r\n    InvertYPremultiplyAlphaWithOfst = 3,\r\n}\r\n\r\nenum VideoPipelineType {\r\n    DontInvertY = 0,\r\n    InvertY = 1,\r\n}\r\n\r\ninterface IPipelineParameters {\r\n    invertY?: boolean;\r\n    premultiplyAlpha?: boolean;\r\n}\r\n\r\nconst shadersForPipelineType = [\r\n    { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },\r\n    { vertex: clearVertexSource, fragment: clearFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource },\r\n];\r\n\r\n/**\r\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\r\n * The number of entries should not go over 64! Else, the code in WebGPUCacheRenderPipeline.setMRT should be updated\r\n */\r\nexport const renderableTextureFormatToIndex: { [name: string]: number } = {\r\n    \"\": 0,\r\n    r8unorm: 1,\r\n    r8uint: 2,\r\n    r8sint: 3,\r\n\r\n    r16uint: 4,\r\n    r16sint: 5,\r\n    r16float: 6,\r\n    rg8unorm: 7,\r\n    rg8uint: 8,\r\n    rg8sint: 9,\r\n\r\n    r32uint: 10,\r\n    r32sint: 11,\r\n    r32float: 12,\r\n    rg16uint: 13,\r\n    rg16sint: 14,\r\n    rg16float: 15,\r\n    rgba8unorm: 16,\r\n    \"rgba8unorm-srgb\": 17,\r\n    rgba8uint: 18,\r\n    rgba8sint: 19,\r\n    bgra8unorm: 20,\r\n    \"bgra8unorm-srgb\": 21,\r\n\r\n    rgb10a2uint: 22,\r\n    rgb10a2unorm: 23,\r\n    /* rg11b10ufloat: this entry is dynamically added if the \"RG11B10UFloatRenderable\" extension is supported */\r\n\r\n    rg32uint: 24,\r\n    rg32sint: 25,\r\n    rg32float: 26,\r\n    rgba16uint: 27,\r\n    rgba16sint: 28,\r\n    rgba16float: 29,\r\n\r\n    rgba32uint: 30,\r\n    rgba32sint: 31,\r\n    rgba32float: 32,\r\n\r\n    stencil8: 33,\r\n    depth16unorm: 34,\r\n    depth24plus: 35,\r\n    \"depth24plus-stencil8\": 36,\r\n    depth32float: 37,\r\n\r\n    \"depth32float-stencil8\": 38,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUTextureManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _mipmapSampler: GPUSampler;\r\n    private _videoSampler: GPUSampler;\r\n    private _ubCopyWithOfst: GPUBuffer;\r\n    private _pipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _compiledShaders: GPUShaderModule[][] = [];\r\n    private _videoPipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _videoCompiledShaders: GPUShaderModule[][] = [];\r\n    private _deferredReleaseTextures: Array<[Nullable<HardwareTextureWrapper | GPUTexture>, Nullable<BaseTexture>]> = [];\r\n    private _commandEncoderForCreation: GPUCommandEncoder;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                         Initialization / Helpers\r\n    //------------------------------------------------------------------------------\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, enabledExtensions: GPUFeatureName[]) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        if (enabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) !== -1) {\r\n            const keys = Object.keys(renderableTextureFormatToIndex);\r\n            renderableTextureFormatToIndex[WebGPUConstants.TextureFormat.RG11B10UFloat] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;\r\n        }\r\n\r\n        this._mipmapSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._videoSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._ubCopyWithOfst = this._bufferManager.createBuffer(\r\n            4 * 4,\r\n            WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n            \"UBCopyWithOffset\"\r\n        ).underlyingResource;\r\n\r\n        this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n        this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n    }\r\n\r\n    private _getPipeline(format: GPUTextureFormat, type: PipelineType = PipelineType.MipMap, params?: IPipelineParameters): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index =\r\n            type === PipelineType.MipMap\r\n                ? 1 << 0\r\n                : type === PipelineType.InvertYPremultiplyAlpha\r\n                  ? ((params!.invertY ? 1 : 0) << 1) + ((params!.premultiplyAlpha ? 1 : 0) << 2)\r\n                  : type === PipelineType.Clear\r\n                    ? 1 << 3\r\n                    : type === PipelineType.InvertYPremultiplyAlphaWithOfst\r\n                      ? ((params!.invertY ? 1 : 0) << 4) + ((params!.premultiplyAlpha ? 1 : 0) << 5)\r\n                      : 0;\r\n\r\n        if (!this._pipelines[format]) {\r\n            this._pipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._pipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let defines = \"\";\r\n            if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\r\n                if (params!.invertY) {\r\n                    defines += \"#define INVERTY\\n\";\r\n                }\r\n                if (params!.premultiplyAlpha) {\r\n                    defines += \"#define PREMULTIPLYALPHA\\n\";\r\n                }\r\n            }\r\n\r\n            let modules = this._compiledShaders[index];\r\n            if (!modules) {\r\n                let vertexCode = shadersForPipelineType[type].vertex;\r\n                let fragmentCode = shadersForPipelineType[type].fragment;\r\n\r\n                const processorOptions: ProcessingOptions = {\r\n                    defines: defines.split(\"\\n\"),\r\n                    indexParameters: null,\r\n                    isFragment: false,\r\n                    shouldUseHighPrecisionShader: true,\r\n                    processor: this._engine._getShaderProcessor(ShaderLanguage.WGSL),\r\n                    supportsUniformBuffers: true,\r\n                    shadersRepository: \"\",\r\n                    includesShadersStore: {},\r\n                    version: (this._engine.version * 100).toString(),\r\n                    platformName: this._engine.shaderPlatformName,\r\n                    processingContext: this._engine._getShaderProcessingContext(ShaderLanguage.WGSL, true),\r\n                    isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                };\r\n\r\n                Initialize(processorOptions);\r\n\r\n                // Disable special additions not needed here\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = true;\r\n\r\n                Process(\r\n                    vertexCode,\r\n                    processorOptions,\r\n                    (migratedVertexCode) => {\r\n                        vertexCode = migratedVertexCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                processorOptions.isFragment = true;\r\n\r\n                Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode) => {\r\n                        fragmentCode = migratedFragmentCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                const final = Finalize(vertexCode, fragmentCode, processorOptions);\r\n\r\n                // Restore\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = false;\r\n\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: final.vertexCode,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: final.fragmentCode,\r\n                });\r\n                modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private _getVideoPipeline(format: GPUTextureFormat, type: VideoPipelineType = VideoPipelineType.DontInvertY): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\r\n\r\n        if (!this._videoPipelines[format]) {\r\n            this._videoPipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._videoPipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let modules = this._videoCompiledShaders[index];\r\n            if (!modules) {\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: copyVideoToTextureVertexSource,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,\r\n                });\r\n                modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    public setCommandEncoder(encoder: GPUCommandEncoder): void {\r\n        this._commandEncoderForCreation = encoder;\r\n    }\r\n\r\n    public copyVideoToTexture(video: ExternalTexture, texture: InternalTexture, format: GPUTextureFormat, invertY = false, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\r\n\r\n        const webgpuHardwareTexture = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}${texture.label ? \"_\" + texture.label : \"\"}`,\r\n            colorAttachments: [\r\n                {\r\n                    view: webgpuHardwareTexture.underlyingResource!.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.All,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: this._videoSampler,\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: this._device.importExternalTexture({\r\n                        source: video.underlyingResource,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public invertYPreMultiplyAlpha(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        faceIndex = 0,\r\n        mipLevel = 0,\r\n        layers = 1,\r\n        ofstX = 0,\r\n        ofstY = 0,\r\n        rectWidth = 0,\r\n        rectHeight = 0,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const useRect = rectWidth !== 0;\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\r\n            invertY,\r\n            premultiplyAlpha,\r\n        });\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\r\n                // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\r\n                gpuOrHdwTexture = undefined as any;\r\n            }\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        if (useRect) {\r\n            this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        const outputTexture =\r\n            webgpuHardwareTexture?._copyInvertYTempTexture ??\r\n            this.createTexture(\r\n                { width, height, layers: 1 },\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                format,\r\n                1,\r\n                commandEncoder,\r\n                WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding,\r\n                undefined,\r\n                \"TempTextureForCopyWithInvertY\"\r\n            );\r\n\r\n        const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}_${\r\n                premultiplyAlpha ? \"PremultiplyAlpha\" : \"DontPremultiplyAlpha\"\r\n            }`,\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        baseMipLevel: 0,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                        baseArrayLayer: 0,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\r\n        if (!bindGroup) {\r\n            const descriptor: GPUBindGroupDescriptor = {\r\n                layout: bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: mipLevel,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: layers,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                    },\r\n                ],\r\n            };\r\n            if (useRect) {\r\n                descriptor.entries.push({\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this._ubCopyWithOfst,\r\n                    },\r\n                });\r\n            }\r\n            bindGroup = this._device.createBindGroup(descriptor);\r\n        }\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.copyTextureToTexture(\r\n            {\r\n                texture: outputTexture,\r\n            },\r\n            {\r\n                texture: gpuTexture,\r\n                mipLevel,\r\n                origin: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    z: faceIndex,\r\n                },\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        if (webgpuHardwareTexture) {\r\n            webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\r\n            webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\r\n            if (useRect) {\r\n                webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\r\n            } else {\r\n                webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\r\n            }\r\n        } else {\r\n            this._deferredReleaseTextures.push([outputTexture, null]);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public copyWithInvertY(srcTextureView: GPUTextureView, format: GPUTextureFormat, renderPassDescriptor: GPURenderPassDescriptor, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, { invertY: true, premultiplyAlpha: false });\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal copy texture with invertY`);\r\n\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const bindGroup = this._device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: srcTextureView,\r\n                },\r\n            ],\r\n        });\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                               Creation\r\n    //------------------------------------------------------------------------------\r\n\r\n    public createTexture(\r\n        imageBitmap: ImageBitmap | { width: number; height: number; layers: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        is3D = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const layerCount = (imageBitmap as any).layers || 1;\r\n        const textureSize = {\r\n            width: imageBitmap.width,\r\n            height: imageBitmap.height,\r\n            depthOrArrayLayers: layerCount,\r\n        };\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat && !is3D) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? \"3D\" : \"2D\"}_${label ? label + \"_\" : \"\"}${textureSize.width}x${textureSize.height}x${\r\n                textureSize.depthOrArrayLayers\r\n            }_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: textureSize,\r\n            dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n            this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, is3D, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public createCubeTexture(\r\n        imageBitmaps: ImageBitmap[] | { width: number; height: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\r\n        const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + \"_\" : \"\"}${width}x${height}x6_${\r\n                hasMipmaps ? \"wmips\" : \"womips\"\r\n            }_${format}_samples${sampleCount}`,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 6,\r\n            },\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\r\n            this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public generateCubeMipmaps(gpuTexture: GPUTexture | WebGPUHardwareTexture, format: GPUTextureFormat, mipLevelCount: number, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\r\n\r\n        for (let f = 0; f < 6; ++f) {\r\n            this.generateMipmaps(gpuTexture, format, mipLevelCount, f, false, commandEncoder);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public generateMipmaps(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        format: GPUTextureFormat,\r\n        mipLevelCount: number,\r\n        faceIndex = 0,\r\n        is3D = false,\r\n        commandEncoder?: GPUCommandEncoder\r\n    ): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format);\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\r\n            gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n        for (let i = 1; i < mipLevelCount; ++i) {\r\n            const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,\r\n                colorAttachments: [\r\n                    {\r\n                        view: gpuTexture.createView({\r\n                            format,\r\n                            dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: i,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: 1,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                        loadOp: WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    },\r\n                ],\r\n            };\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\r\n            }\r\n            const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n            const bindGroup =\r\n                webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ??\r\n                this._device.createBindGroup({\r\n                    layout: bindGroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: gpuTexture.createView({\r\n                                format,\r\n                                dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                                baseMipLevel: i - 1,\r\n                                mipLevelCount: 1,\r\n                                arrayLayerCount: 1,\r\n                                baseArrayLayer: faceIndex,\r\n                            }),\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: this._mipmapSampler,\r\n                        },\r\n                    ],\r\n                });\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\r\n            }\r\n\r\n            passEncoder.setPipeline(pipeline);\r\n            passEncoder.setBindGroup(0, bindGroup);\r\n            passEncoder.draw(4, 1, 0, 0);\r\n            passEncoder.end();\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public createGPUTextureForInternalTexture(texture: InternalTexture, width?: number, height?: number, depth?: number, creationFlags?: number): WebGPUHardwareTexture {\r\n        if (!texture._hardwareTexture) {\r\n            texture._hardwareTexture = new WebGPUHardwareTexture();\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = texture.width;\r\n        }\r\n        if (height === undefined) {\r\n            height = texture.height;\r\n        }\r\n        if (depth === undefined) {\r\n            depth = texture.depth;\r\n        }\r\n\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const isStorageTexture = ((creationFlags ?? 0) & Constants.TEXTURE_CREATIONFLAG_STORAGE) !== 0;\r\n\r\n        gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\r\n\r\n        gpuTextureWrapper.textureUsages =\r\n            texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : texture._source === InternalTextureSource.DepthStencil\r\n                  ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment\r\n                  : -1;\r\n\r\n        gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\r\n\r\n        const hasMipMaps = texture.generateMipMaps;\r\n        const layerCount = depth || 1;\r\n        let mipmapCount;\r\n        if (texture._maxLodLevel !== null) {\r\n            mipmapCount = texture._maxLodLevel;\r\n        } else {\r\n            mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width!, height!) : 1;\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            const gpuTexture = this.createCubeTexture(\r\n                { width, height },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${\r\n                        hasMipMaps ? \"wmips\" : \"womips\"\r\n                    }_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: 6,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        } else {\r\n            const gpuTexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray\r\n                ? WebGPUConstants.TextureViewDimension.E2dArray\r\n                : texture.is3D\r\n                  ? WebGPUConstants.TextureDimension.E3d\r\n                  : WebGPUConstants.TextureViewDimension.E2d;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? \"3D\" : \"2D\"}${\r\n                        texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"\r\n                    }_${width}x${height}${texture.is3D ? \"x\" + layerCount : \"\"}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        }\r\n\r\n        texture.width = texture.baseWidth = width;\r\n        texture.height = texture.baseHeight = height;\r\n        texture.depth = texture.baseDepth = depth;\r\n\r\n        this.createMSAATexture(texture, texture.samples);\r\n\r\n        return gpuTextureWrapper;\r\n    }\r\n\r\n    public createMSAATexture(texture: InternalTexture, samples: number, releaseExisting = true, index = -1): void {\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (releaseExisting) {\r\n            gpuTextureWrapper?.releaseMSAATexture();\r\n        }\r\n\r\n        if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n\r\n        const gpuMSAATexture = this.createTexture(\r\n            { width, height, layers: 1 },\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            gpuTextureWrapper.format,\r\n            samples,\r\n            this._commandEncoderForCreation,\r\n            WebGPUConstants.TextureUsage.RenderAttachment,\r\n            0,\r\n            texture.label ? \"MSAA\" + texture.label : undefined\r\n        );\r\n        gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                                  Update\r\n    //------------------------------------------------------------------------------\r\n\r\n    public updateCubeTextures(\r\n        imageBitmaps: ImageBitmap[] | Uint8Array[],\r\n        gpuTexture: GPUTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0\r\n    ): void {\r\n        const faces = [0, 3, 1, 4, 2, 5];\r\n\r\n        for (let f = 0; f < faces.length; ++f) {\r\n            const imageBitmap = imageBitmaps[faces[f]];\r\n\r\n            this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\r\n        }\r\n    }\r\n\r\n    // TODO WEBGPU handle data source not being in the same format than the destination texture?\r\n    public updateTexture(\r\n        imageBitmap: ImageBitmap | Uint8Array | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas,\r\n        texture: GPUTexture | InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        layers: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture).underlyingResource! : texture;\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n        const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture) : texture;\r\n\r\n        const textureCopyView: GPUImageCopyTextureTagged = {\r\n            texture: gpuTexture,\r\n            origin: {\r\n                x: offsetX,\r\n                y: offsetY,\r\n                z: Math.max(faceIndex, 0),\r\n            },\r\n            mipLevel: mipLevel,\r\n            premultipliedAlpha: premultiplyAlpha,\r\n        };\r\n\r\n        const textureExtent = {\r\n            width: Math.ceil(width / blockInformation.width) * blockInformation.width,\r\n            height: Math.ceil(height / blockInformation.height) * blockInformation.height,\r\n            depthOrArrayLayers: layers || 1,\r\n        };\r\n\r\n        if ((imageBitmap as Uint8Array).byteLength !== undefined) {\r\n            imageBitmap = imageBitmap as Uint8Array;\r\n\r\n            const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n            const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\r\n\r\n            if (aligned) {\r\n                const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                const buffer = this._bufferManager.createRawBuffer(\r\n                    imageBitmap.byteLength,\r\n                    WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc,\r\n                    true,\r\n                    \"TempBufferForUpdateTexture\" + (gpuTexture ? \"_\" + gpuTexture.label : \"\")\r\n                );\r\n\r\n                const arrayBuffer = buffer.getMappedRange();\r\n\r\n                new Uint8Array(arrayBuffer).set(imageBitmap);\r\n\r\n                buffer.unmap();\r\n\r\n                commandEncoder!.copyBufferToTexture(\r\n                    {\r\n                        buffer: buffer,\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureCopyView,\r\n                    textureExtent\r\n                );\r\n\r\n                this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n                this._bufferManager.releaseBuffer(buffer);\r\n            } else {\r\n                this._device.queue.writeTexture(\r\n                    textureCopyView,\r\n                    imageBitmap,\r\n                    {\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureExtent\r\n                );\r\n            }\r\n\r\n            if (invertY || premultiplyAlpha) {\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n                    const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        texture.width,\r\n                        texture.height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        offsetX,\r\n                        offsetY,\r\n                        dontUseRect ? 0 : width,\r\n                        dontUseRect ? 0 : height,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we should never take this code path\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\r\n                }\r\n            }\r\n        } else {\r\n            imageBitmap = imageBitmap as ImageBitmap | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas;\r\n\r\n            if (invertY) {\r\n                textureCopyView.premultipliedAlpha = false; // we are going to handle premultiplyAlpha ourselves\r\n\r\n                // we must preprocess the image\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {\r\n                    // optimization when the source image is the same size than the destination texture and offsets X/Y == 0:\r\n                    // we simply copy the source to the destination and we apply the preprocessing on the destination\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we must apply the preprocessing on the source image before copying it into the destination texture\r\n                    const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                    // create a temp texture and copy the image to it\r\n                    const srcTexture = this.createTexture(\r\n                        { width, height, layers: 1 },\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        format,\r\n                        1,\r\n                        commandEncoder,\r\n                        WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.TextureBinding,\r\n                        undefined,\r\n                        \"TempTextureForUpdateTexture\"\r\n                    );\r\n\r\n                    this._deferredReleaseTextures.push([srcTexture, null]);\r\n\r\n                    textureExtent.depthOrArrayLayers = 1;\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: srcTexture }, textureExtent);\r\n                    textureExtent.depthOrArrayLayers = layers || 1;\r\n\r\n                    // apply the preprocessing to this temp texture\r\n                    this.invertYPreMultiplyAlpha(\r\n                        srcTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        commandEncoder,\r\n                        allowGPUOptimization\r\n                    );\r\n\r\n                    // copy the temp texture to the destination texture\r\n                    commandEncoder.copyTextureToTexture({ texture: srcTexture }, textureCopyView, textureExtent);\r\n\r\n                    this._device.queue.submit([commandEncoder!.finish()]);\r\n                }\r\n            } else {\r\n                // no preprocessing: direct copy to destination texture\r\n                this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n            }\r\n        }\r\n    }\r\n\r\n    public readPixels(\r\n        texture: GPUTexture,\r\n        x: number,\r\n        y: number,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n\r\n        const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n\r\n        const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\r\n\r\n        const size = bytesPerRowAligned * height;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempBufferForReadPixels\" + (texture.label ? \"_\" + texture.label : \"\")\r\n        );\r\n\r\n        const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n            {\r\n                texture,\r\n                mipLevel,\r\n                origin: {\r\n                    x,\r\n                    y,\r\n                    z: Math.max(faceIndex, 0),\r\n                },\r\n            },\r\n            {\r\n                buffer: gpuBuffer,\r\n                offset: 0,\r\n                bytesPerRow: bytesPerRowAligned,\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n        return this._bufferManager.readDataFromBuffer(\r\n            gpuBuffer,\r\n            size,\r\n            width,\r\n            height,\r\n            bytesPerRow,\r\n            bytesPerRowAligned,\r\n            WebGPUTextureHelper.GetTextureTypeFromFormat(format),\r\n            0,\r\n            buffer,\r\n            true,\r\n            noDataConversion\r\n        );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    public releaseTexture(texture: InternalTexture | GPUTexture): void {\r\n        if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n            const hardwareTexture = texture._hardwareTexture;\r\n            const irradianceTexture = texture._irradianceTexture;\r\n\r\n            // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\r\n            this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\r\n        } else {\r\n            this._deferredReleaseTextures.push([texture, null]);\r\n        }\r\n    }\r\n\r\n    public destroyDeferredTextures(): void {\r\n        for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\r\n            const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\r\n\r\n            if (hardwareTexture) {\r\n                if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {\r\n                    hardwareTexture.release();\r\n                } else {\r\n                    hardwareTexture.destroy();\r\n                }\r\n            }\r\n            irradianceTexture?.dispose();\r\n        }\r\n\r\n        this._deferredReleaseTextures.length = 0;\r\n    }\r\n}\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { PerfCounter } from \"../../Misc/perfCounter\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/** @internal */\r\nexport class WebGPUTimestampQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _enabled = false;\r\n    private _gpuFrameTimeCounter: PerfCounter = new PerfCounter();\r\n    private _measureDuration: WebGPUDurationMeasure;\r\n    private _measureDurationState = 0;\r\n\r\n    public get gpuFrameTimeCounter() {\r\n        return this._gpuFrameTimeCounter;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n    }\r\n\r\n    public get enable(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enable(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._measureDurationState = 0;\r\n        if (value) {\r\n            try {\r\n                this._measureDuration = new WebGPUDurationMeasure(this._engine, this._device, this._bufferManager, 2000, \"QuerySet_TimestampQuery\");\r\n            } catch (e) {\r\n                this._enabled = false;\r\n                Logger.Error(\"Could not create a WebGPUDurationMeasure!\\nError: \" + e.message + \"\\nMake sure timestamp query is supported and enabled in your browser.\");\r\n                return;\r\n            }\r\n        } else {\r\n            this._measureDuration.dispose();\r\n        }\r\n    }\r\n\r\n    public startFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._enabled && this._measureDurationState === 0) {\r\n            this._measureDuration.start(commandEncoder);\r\n            this._measureDurationState = 1;\r\n        }\r\n    }\r\n\r\n    public endFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._measureDurationState === 1) {\r\n            this._measureDurationState = 2;\r\n            this._measureDuration.stop(commandEncoder).then((duration) => {\r\n                if (duration !== null && duration >= 0) {\r\n                    this._gpuFrameTimeCounter.fetchNewFrame();\r\n                    this._gpuFrameTimeCounter.addCount(duration, true);\r\n                }\r\n                this._measureDurationState = 0;\r\n            });\r\n        }\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (this._enabled) {\r\n            this._measureDuration.startPass(descriptor, index);\r\n        } else {\r\n            descriptor.timestampWrites = undefined;\r\n        }\r\n    }\r\n\r\n    public endPass(index: number, gpuPerfCounter?: WebGPUPerfCounter): void {\r\n        if (!this._enabled || !gpuPerfCounter) {\r\n            return;\r\n        }\r\n\r\n        const currentFrameId = this._engine.frameId;\r\n\r\n        this._measureDuration.stopPass(index).then((duration_) => {\r\n            gpuPerfCounter._addDuration(currentFrameId, duration_ !== null && duration_ > 0 ? duration_ : 0);\r\n        });\r\n    }\r\n\r\n    public dispose() {\r\n        this._measureDuration?.dispose();\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUDurationMeasure {\r\n    private _querySet: WebGPUQuerySet;\r\n    private _count: number;\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, count = 2, querySetLabel?: string) {\r\n        this._count = count;\r\n        this._querySet = new WebGPUQuerySet(engine, count, WebGPUConstants.QueryType.Timestamp, device, bufferManager, true, querySetLabel);\r\n    }\r\n\r\n    public start(encoder: GPUCommandEncoder): void {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 0);\r\n    }\r\n\r\n    public async stop(encoder: GPUCommandEncoder): Promise<number | null> {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 1);\r\n\r\n        return encoder.writeTimestamp ? this._querySet.readTwoValuesAndSubtract(0) : 0;\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (index + 3 > this._count) {\r\n            throw new Error(\"WebGPUDurationMeasure: index out of range (\" + index + \")\");\r\n        }\r\n\r\n        descriptor.timestampWrites = {\r\n            querySet: this._querySet.querySet,\r\n            beginningOfPassWriteIndex: index + 2,\r\n            endOfPassWriteIndex: index + 3,\r\n        };\r\n    }\r\n\r\n    public async stopPass(index: number): Promise<number | null> {\r\n        return this._querySet.readTwoValuesAndSubtract(index + 2);\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.dispose();\r\n    }\r\n}\r\n","import { Logger } from \"core/Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options to load the associated Twgsl library\r\n */\r\nexport interface TwgslOptions {\r\n    /**\r\n     * Defines an existing instance of Twgsl (useful in modules who do not access the global instance).\r\n     */\r\n    twgsl?: any;\r\n    /**\r\n     * Defines the URL of the twgsl JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the twgsl WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUTintWASM {\r\n    // Default twgsl options.\r\n    private static readonly _TWgslDefaultOptions: TwgslOptions = {\r\n        jsPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.js`,\r\n        wasmPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.wasm`,\r\n    };\r\n\r\n    public static ShowWGSLShaderCode = false;\r\n\r\n    public static DisableUniformityAnalysis = false;\r\n\r\n    private static _Twgsl: any = null;\r\n\r\n    public async initTwgsl(twgslOptions?: TwgslOptions): Promise<void> {\r\n        if (WebGPUTintWASM._Twgsl) {\r\n            return;\r\n        }\r\n\r\n        twgslOptions = twgslOptions || {};\r\n        twgslOptions = {\r\n            ...WebGPUTintWASM._TWgslDefaultOptions,\r\n            ...twgslOptions,\r\n        };\r\n\r\n        if (twgslOptions.twgsl) {\r\n            WebGPUTintWASM._Twgsl = twgslOptions.twgsl;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (twgslOptions.jsPath && twgslOptions.wasmPath) {\r\n            await Tools.LoadBabylonScriptAsync(twgslOptions.jsPath);\r\n        }\r\n\r\n        if ((self as any).twgsl) {\r\n            WebGPUTintWASM._Twgsl = await (self as any).twgsl(Tools.GetBabylonScriptURL(twgslOptions!.wasmPath!));\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"twgsl is not available.\");\r\n    }\r\n\r\n    public convertSpirV2WGSL(code: Uint32Array, disableUniformityAnalysis = false): string {\r\n        const ccode = WebGPUTintWASM._Twgsl.convertSpirV2WGSL(code, WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis);\r\n        if (WebGPUTintWASM.ShowWGSLShaderCode) {\r\n            Logger.Log(ccode);\r\n            Logger.Log(\"***********************************************\");\r\n        }\r\n        return WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis ? \"diagnostic(off, derivative_uniformity);\\n\" + ccode : ccode;\r\n    }\r\n}\r\n"],"names":["prototype","setAlphaMode","mode","noDepthWriteChange","this","_alphaMode","depthMask","depthCullingState","setDepthWrite","_cacheRenderPipeline","setDepthWriteEnabled","_alphaState","alphaBlend","setAlphaBlendFunctionParameters","setAlphaBlendEnabled","setAlphaBlendFactors","_blendFunctionParameters","_blendEquationParameters","setAlphaEquation","equation","call","WebGPUComputeContext","getBindGroups","bindings","computePipeline","bindingsMapping","Error","_bindGroups","length","bindGroupEntriesExist","_bindGroupEntries","key","binding","location","group","index","type","object","indexInGroupEntries","entries","sampler","undefined","resource","_cacheSampler","getSampler","push","texture","hardwareTexture","_texture","_hardwareTexture","view","textureAdditionalUsages","name","uniqueId","viewForWriting","externalTexture","underlyingResource","_device","importExternalTexture","source","dataBuffer","getBuffer","webgpuBuffer","buffer","size","capacity","offset","i","createBindGroup","layout","getBindGroupLayout","constructor","device","cacheSampler","_Counter","clear","WebGPUComputePipelineContext","isAsync","isReady","engine","_name","_getComputeShaderCode","sources","compute","dispose","computePassDescriptor","createComputeContext","createComputeEffect","baseName","options","computeToken","computeSource","computeElement","defines","_compiledComputeEffects","compiledEffect","onCompiled","effect","createComputePipelineContext","areAllComputeEffectsReady","computeDispatch","context","x","y","z","gpuPerfCounter","_computeDispatch","computeDispatchIndirect","_endCurrentRenderPass","contextPipeline","_pipelineContext","computeContext","createComputePipeline","stage","_timestampQuery","startPass","_timestampIndex","computePass","_renderEncoder","beginComputePass","setPipeline","bindGroups","bindGroup","setBindGroup","dispatchWorkgroupsIndirect","dispatchWorkgroups","end","endPass","releaseComputeEffects","webGPUPipelineContextCompute","getPipelineContext","_deleteComputePipelineContext","_prepareComputePipelineContext","pipelineContext","computeSourceCode","rawComputeSourceCode","entryPoint","webGpuContext","dbgShowShaderCode","Log","rawCompute","_createComputePipelineStageDescriptor","_releaseComputeEffect","_key","_rebuildComputeEffects","_wasPreviouslyReady","_prepareEffect","_executeWhenComputeStateIsCompiled","action","module","getCompilationInfo","then","info","compilationMessages","numErrors","messages","message","text","line","lineNum","column","linePos","computeShader","split","join","createShaderModule","code","_createDepthStencilCubeTexture","internalTexture","generateStencil","isCube","label","internalOptions","bilinearFiltering","comparisonFunction","samples","depthTextureFormat","format","_setupDepthStencilTexture","_textureHelper","createGPUTextureForInternalTexture","gpuTextureWrapper","GetTextureTypeFromFormat","_internalTexturesCache","createCubeTexture","rootUrl","scene","files","noMipmap","onLoad","onError","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","loaderOptions","useSRGBBuffer","createCubeTextureBase","imgs","imageBitmaps","width","height","_setCubeMapTextureParams","updateCubeTextures","_generateMipmaps","_uploadEncoder","onLoadedObservable","notifyObservers","loadMipmap","maxLevel","samplingMode","_cachedWrapU","_cachedWrapV","_maxLodLevel","generateMipMapsForCubemap","generateMipMaps","gpuTexture","_debugPushGroup","groupName","targetObject","_options","enableGPUDebugMarkers","pushDebugGroup","_currentRenderPass","_pendingDebugCommands","_debugPopGroup","popDebugGroup","_debugInsertMarker","insertDebugMarker","_debugFlushPendingCommands","param","createDynamicTexture","baseWidth","baseHeight","needPOTTextures","_caps","maxTextureSize","updateTextureSamplingMode","updateDynamicTexture","invertY","premulAlpha","forceBindTexture","allowGPUOptimization","updateTexture","depth","_dynamicTextureSource","_premulAlpha","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","count","_attachments","textures","is3D","_currentRenderTarget","_mrtAttachments","setMRT","setMRTAttachments","createMultipleRenderTarget","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","textureCount","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","_createHardwareRenderTargetWrapper","targetTypes","layerCounts","depthStencilTexture","createDepthStencilTexture","attachments","defaultAttachments","_generateDepthBuffer","_generateStencilBuffer","_defaultAttachments","supportSRGBBuffers","target","layerCount","Warn","baseDepth","is2DArray","_useSRGBBuffer","incrementReferences","setTextures","setLayerAndFaceIndices","updateMultipleRenderTargetTextureSampleCount","Math","min","getCaps","maxMSAASamples","releaseMSAATexture","lastTextureIsDepthTexture","_depthStencilTexture","createMSAATexture","bindAttachments","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget","_convertRGBtoRGBATextureData","rgbData","textureType","rgbaData","val1","Float32Array","Uint16Array","Uint32Array","Uint8Array","newIndex","getGPUFrameTimeCounter","gpuFrameTimeCounter","captureGPUFrameTime","value","enable","timerQuery","createQuery","_occlusionQuery","deleteQuery","query","isQueryResultAvailable","getQueryResult","beginOcclusionQuery","algorithmType","compatibilityMode","canBeginQuery","_bundleList","addItem","endOcclusionQuery","createRawTexture","data","compression","_compression","_creationFlags","creationFlags","_doNotHandleContextLost","_bufferView","updateRawTexture","bufferView","byteOffset","byteLength","createRawCubeTexture","_originalFormat","_bufferViewArray","_originalFormatIsRGB","updateRawCubeTexture","_format","needConversion","faces","faceData","createRawCubeTextureFromUrl","url","callback","mipmapGenerator","addPendingData","internalCallback","faceDataArrays","mipData","level","mipSize","allFaces","mipFaceData","removePendingData","_loadFile","offlineProvider","request","exception","status","statusText","createRawTexture3D","updateRawTexture3D","createRawTexture2DArray","updateRawTexture2DArray","_readTexturePixels","flushRenderer","noDataConversion","flushFramebuffer","readPixels","_readTexturePixelsSync","WebGPURenderTargetWrapper","isMulti","super","enableGPUTimingMeasurements","gpuTimeInFrame","_renderTargetWrapperCache","createRenderTargetTexture","fullOptions","noColorAttachment","_createInternalTexture","_samples","createMipMaps","_createDepthStencilTexture","_comparisonFunction","updateRenderTargetTextureSampleCount","createRenderTargetCubeTexture","setDepthStencilTexture","channel","uniform","_setTexture","updateVideoTexture","video","_isDisabled","_videoTextureSupported","IsExternalTexture","copyVideoToTexture","e","createImageBitmap","bitmap","catch","WebGPUDataBuffer","engineId","_buffer","WebGPUBufferManager","_IsGPUBuffer","_FlagsToString","flags","suffix","_deferredReleaseBuffers","_engine","createRawBuffer","viewOrSize","mappedAtCreation","alignedLength","verticesBufferDescriptor","usage","createBuffer","isView","references","setSubData","setRawData","dstByteOffset","src","srcByteOffset","queue","writeBuffer","chunkStart","chunkEnd","tempView","slice","set","maxChunk","_getHalfFloatAsFloatRGBAArrayBuffer","dataLength","arrayBuffer","destArray","srcData","readDataFromBuffer","gpuBuffer","bytesPerRow","bytesPerRowAligned","floatFormat","Promise","resolve","reject","mapAsync","copyArrayBuffer","getMappedRange","data2","offset2","unmap","destroyBuffer","releaseBuffer","reason","isDisposed","destroyDeferredBuffers","destroy","WebGPURenderItemViewport","w","h","floor","run","renderPass","setViewport","clone","WebGPURenderItemScissor","setScissorRect","WebGPURenderItemStencilRef","ref","setStencilReference","WebGPURenderItemBlendColor","color","setBlendConstant","WebGPURenderItemBeginOcclusionQuery","WebGPURenderItemEndOcclusionQuery","WebGPURenderItemBundles","bundles","executeBundles","cloned","WebGPUBundleList","numDrawCalls","_list","Array","_listLength","addBundle","bundle","_currentItemIsBundle","item","_currentBundleList","_finishBundle","_bundleEncoder","finish","getBundleEncoder","colorFormats","depthStencilFormat","sampleCount","createRenderBundleEncoder","GetSample","close","reset","WebGPUBindGroupCacheNode","values","WebGPUCacheBindGroups","Statistics","totalCreated","NumBindGroupsCreatedTotal","lastFrameCreated","NumBindGroupsCreatedLastFrame","lookupLastFrame","NumBindGroupsLookupLastFrame","noLookupLastFrame","NumBindGroupsNoLookupLastFrame","ResetCache","_Cache","_NumBindGroupsCreatedCurrentFrame","_NumBindGroupsLookupCurrentFrame","_NumBindGroupsNoLookupCurrentFrame","disabled","endFrame","webgpuPipelineContext","drawContext","materialContext","node","cacheIsDisabled","forceBindGroupCreation","isDirty","updateId","bufferName","shaderProcessingContext","bufferNames","uboId","buffers","nextNode","samplerName","samplerNames","samplerHashCode","samplers","hashCode","textureName","textureNames","textureId","resetIsDirty","bindGroupLayouts","textureState","bindGroupLayoutEntries","setDefinition","bindGroupEntries","j","entry","entryInfo","bindGroupLayoutEntryInfo","nameInArrayOfTexture","bindingInfo","dbgSanityChecks","JSON","stringify","storageTexture","groupLayout","StatePosition","alphaBlendFactorToIndex","stencilOpToIndex","WebGPUCacheRenderPipeline","emptyVertexBuffer","mrtTextureCount","_useTextureStage","_states","_statesLength","_stateDirtyLowestIndex","_emptyVertexBuffer","_mrtFormats","_parameter","token","pipeline","vertexBuffers","_kMaxVertexBufferStride","limits","maxVertexBufferArrayStride","_isDirty","setAlphaToCoverage","resetDepthCullingState","setClampDepth","setDepthBias","_webgpuColorFormat","setColorFormat","setWriteMask","setDepthStencilFormat","setStencilEnabled","resetStencilState","setBuffers","_setTextureState","_mrtAttachments1","getRenderPipeline","fillMode","topology","_GetTopology","_setVertexState","_createRenderPipeline","NumCacheMiss","_NumPipelineCreationCurrentFrame","_setShaderStage","_setRasterizationState","_setColorStates","_setDepthStencilState","lastStateDirtyLowestIndex","NumCacheHitWithoutHash","_getRenderPipeline","NumCacheHitWithHash","_setRenderPipeline","NumPipelineCreationLastFrame","enabled","_alphaToCoverageEnabled","setFrontFace","frontFace","_frontFace","setCullEnabled","_cullEnabled","setCullFace","cullFace","_cullFace","clampDepth","_clampDepth","setDepthCullingState","cullEnabled","zOffset","zOffsetUnits","depthTestEnabled","depthWriteEnabled","depthCompare","_depthWriteEnabled","_depthTestEnabled","_depthCompare","setDepthBiasSlopeScale","depthBias","_depthBias","DepthBias","depthBiasSlopeScale","_depthBiasSlopeScale","DepthBiasSlopeScale","_colorFormat","mrtAttachments","mask","_mrtEnabledMask","MRTAttachments1","textureArray","mrtTextureArray","bits","indexBits","numRT","gpuWrapper","_mrtAttachments2","MRTAttachments2","_alphaBlendEnabled","factors","operations","_alphaBlendFuncParams","_alphaBlendEqParams","_writeMask","_webgpuDepthStencilFormat","_depthStencilFormat","setDepthTestEnabled","setDepthCompare","func","_stencilEnabled","setStencilCompare","_stencilFrontCompare","setStencilDepthFailOp","op","_stencilFrontDepthFailOp","setStencilPassOp","_stencilFrontPassOp","setStencilFailOp","_stencilFrontFailOp","setStencilReadMask","_stencilReadMask","StencilReadMask","setStencilWriteMask","_stencilWriteMask","StencilWriteMask","setStencilState","stencilEnabled","compare","depthFailOp","passOp","failOp","readMask","writeMask","indexBuffer","overrideVertexBuffers","_vertexBuffers","_overrideVertexBuffers","_indexBuffer","_GetAphaBlendOperation","operation","_GetAphaBlendFactor","factor","_GetCompareFunction","compareFunction","_GetStencilOpFunction","_GetVertexInputDescriptorFormat","vertexBuffer","normalized","getSize","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","getKind","_getAphaBlendState","srcFactor","dstFactor","_getColorBlendState","id","_shaderId","ShaderStage","rasterizationState","_rasterizationState","RasterizationState","colorStates","_colorStates","ColorStates","stencilState","depthStencilState","_depthStencilState","DepthStencilState","currStateLen","newNumStates","VertexState","attributes","attributeNamesFromEffect","locations","attributeLocationsFromEffect","currentGPUBuffer","numVertexBuffers","effectiveBuffer","_validOffsetRange","effectiveByteOffset","formatSize","byteStride","effectiveByteStride","vid","_textureState","TextureStage","_createPipelineLayout","_createPipelineLayoutWithTextureStage","createBindGroupLayout","createPipelineLayout","bitVal","textureInfo","availableTextures","samplerInfo","autoBindSampler","availableSamplers","sampleType","samplerType","groupIndex","bindingIndex","_getVertexInputDescriptor","descriptors","currentGPUAttributes","invalidOffsetRange","vertexBufferDescriptor","arrayStride","stepMode","getIsInstanced","shaderLocation","inputStateDescriptor","pipelineLayout","colorBlend","descr","blend","alpha","stencilFrontBack","stripIndexFormat","is32Bits","depthStencilFormatHasStencil","HasStencilAspect","createRenderPipeline","vertex","stages","vertexStage","primitive","cullMode","fragment","fragmentStage","multisample","depthStencil","stencilFront","stencilBack","stencilReadMask","stencilWriteMask","depthBiasClamp","_depthBiasClamp","NodeState","countNode","countPipeline","childCountNodes","childCoundPipeline","WebGPUCacheRenderPipelineTree","GetNodeCounts","counts","nodeCount","pipelineCount","_GetPipelines","pipelines","curPath","curPathLen","path","nnode","parseInt","GetPipelines","_nodeStack","nn","filterToBits","comparisonFunctionToBits","filterNoMipToBits","WebGPUCacheSampler","_samplers","GetSamplerHashCode","anisotropy","_cachedAnisotropicFilteringLevel","_cachedWrapR","useMipMaps","_GetSamplerFilterDescriptor","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","anisotropyEnabled","_GetWrappingMode","_GetSamplerWrappingDescriptor","addressModeU","addressModeV","addressModeW","_GetSamplerDescriptor","filterDescriptor","GetCompareFunction","maxAnisotropy","bypassCache","hash","createSampler","gpuSampler","WebGPUClearQuad","_depthTextureFormat","_bundleCache","_keyTemp","_effect","createEffect","clearColor","clearDepth","clearStencil","renderPass2","bundleKey","isRTTPass","idx","depthStencilFormatIndex","r","g","b","a","useReverseDepthBuffer","setDirectColor4","setFloat","_clearReverseDepthValue","_clearDepthValue","uniformBuffer","update","bufferInternals","_ubInvertY","_ubDontInvertY","bufferLeftOver","_SimplifiedKnownBindings","draw","PowerPreference","FeatureName","BufferMapState","BufferUsage","MapMode","TextureDimension","TextureUsage","TextureViewDimension","TextureAspect","TextureFormat","AddressMode","FilterMode","MipmapFilterMode","CompareFunction","BufferBindingType","SamplerBindingType","TextureSampleType","StorageTextureAccess","CompilationMessageType","PipelineErrorReason","AutoLayoutMode","PrimitiveTopology","FrontFace","CullMode","ColorWrite","BlendFactor","BlendOperation","StencilOperation","IndexFormat","VertexFormat","VertexStepMode","ComputePassTimestampLocation","RenderPassTimestampLocation","LoadOp","StoreOp","QueryType","CanvasAlphaMode","DeviceLostReason","ErrorFilter","WebGPUDepthCullingState","cache","_cache","_zOffset","_isZOffsetDirty","_zOffsetUnits","_isCullFaceDirty","cull","_cull","_isCullDirty","depthFunc","_depthFunc","_isDepthFuncDirty","_depthMask","_isDepthMaskDirty","depthTest","_depthTest","_isDepthTestDirty","_isFrontFaceDirty","apply","WebGPUDrawContext","materialContextUpdateId","_materialContextUpdateId","useInstancing","_useInstancing","use","indirectDrawBuffer","_bufferManager","CopyDst","Indirect","Storage","_indirectDrawData","_currentInstanceCount","bufferManager","fastBundle","setBuffer","setIndirectData","indexOrVertexCount","instanceCount","firstIndexOrVertex","WebGPUExternalTexture","WebGPUHardwareTexture","_webgpuTexture","getMSAATexture","_webgpuMSAATexture","setMSAATexture","existingTexture","textureUsages","setUsage","_textureSource","viewDimension","arrayLayerCount","GetDepthFormatOnly","aspect","HasDepthAndStencilAspects","createView","dimension","mipLevelCount","ILog2","max","baseArrayLayer","baseMipLevel","descriptor","createViewForWriting","saveNumMipMaps","release","_copyInvertYTempTexture","WebGPUMaterialContext","_numExternalTextures","hasFloatOrDepthTextures","_numFloatOrDepthTextures","setSampler","samplerCache","currentHashCode","setTexture","textureCache","currentTextureId","isFloatOrDepthTexture","isExternalTexture","WebGPUOcclusionQuery","querySet","_querySet","hasQueries","_currentTotalIndices","_availableIndices","_frameQuerySetIsDirty","frameId","_queryFrameId","canBegin","_getCurrentRenderPassWrapper","renderPassDescriptor","occlusionQuerySet","startCount","incrementCount","_frameLastBuffer","_countIncrement","_allocateNewIndices","_retrieveQueryBuffer","_lastBuffer","Number","readValues","numIndices","_delayQuerySetDispose","setTimeout","WebGPUPerfCounter","_gpuTimeInFrameId","counter","_addDuration","currentFrameId","duration","_fetchResult","fetchNewFrame","addCount","WebGPUPipelineContext","_leftOverUniformsByName","vertexBufferKindToType","_handlesSpectorRebuildCallback","_fillEffectInformation","uniformBuffersNames","uniformsNames","uniforms","samplerList","attributesNames","_fragmentSourceCode","_vertexSourceCode","foundSamplers","splice","attr","getAttributes","buildUniformLayout","leftOverUniforms","leftOverUniform","replace","UniformSizes","addUniform","create","setEngine","setInt","uniformName","updateInt","setInt2","updateInt2","setInt3","updateInt3","setInt4","updateInt4","setIntArray","array","updateIntArray","setIntArray2","setIntArray3","setIntArray4","setUInt","updateUInt","setUInt2","updateUInt2","setUInt3","updateUInt3","setUInt4","updateUInt4","setUIntArray","updateUIntArray","setUIntArray2","setUIntArray3","setUIntArray4","setArray","updateArray","setArray2","setArray3","setArray4","setMatrices","matrices","updateMatrices","setMatrix","matrix","updateMatrix","setMatrix3x3","updateMatrix3x3","setMatrix2x2","updateMatrix2x2","updateFloat","setVector2","vector2","setFloat2","updateFloat2","setVector3","vector3","setFloat3","updateFloat3","setVector4","vector4","setFloat4","setQuaternion","quaternion","updateFloat4","setColor3","color3","setColor4","color4","_getVertexShaderCode","_getFragmentShaderCode","WebGPUQuerySet","canUseMultipleBuffers","_dstBuffers","_count","_canUseMultipleBuffers","createQuerySet","_queryBuffer","QueryResolve","CopySrc","MapRead","_getBuffer","firstQuery","queryCount","encoderResult","createCommandEncoder","resolveQuerySet","copyBufferToBuffer","submit","arrayBuf","BigUint64Array","err","readValue","readTwoValuesAndSubtract","_typeToLocationSize","mat2","mat3","mat4","mat2x2","mat3x3","mat4x4","WebGPUShaderProcessingContext","KnownUBOs","_SimplifiedKnownUBOs","_KnownUBOs","shaderLanguage","pureMode","vertexBufferKindToNumberOfComponents","_attributeNextLocation","_varyingNextLocation","freeGroupIndex","freeBindingIndex","availableVaryings","availableAttributes","availableBuffers","orderedAttributes","_findStartingGroupBinding","knownUBOs","groups","getAttributeNextLocation","dataType","arrayLength","getVaryingNextLocation","getNextFreeUBOBinding","_getNextFreeBinding","bindingCount","returnValue","Scene","Light0","Light1","Light2","Light3","Light4","Light5","Light6","Light7","Light8","Light9","Light10","Light11","Light12","Light13","Light14","Light15","Light16","Light17","Light18","Light19","Light20","Light21","Light22","Light23","Light24","Light25","Light26","Light27","Light28","Light29","Light30","Light31","Material","Mesh","Internals","WebGPUShaderProcessor","_addUniformToLeftOverUBO","uniformType","preProcessors","_getArraySize","_webgpuProcessingContext","_buildLeftOverUBO","LeftOvertUBOName","availableUBO","_addBufferBindingDescription","_generateLeftOverUBOCode","_collectBindingNames","_preCreateBindGroupEntries","_addTextureBindingDescription","textureIndex","isVertex","len","visibility","access","multisampled","isTextureArray","_addSamplerBindingDescription","uniformBufferInfo","bufferType","InternalsUBOName","bool","int","float","vec2","ivec2","uvec2","vec3","ivec3","uvec3","vec4","ivec4","uvec4","i32","u32","f32","mat2x2f","mat3x3f","mat4x4f","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","_SamplerFunctionByWebGLSamplerType","sampler2D","sampler2DArray","sampler2DShadow","sampler2DArrayShadow","samplerCube","sampler3D","_TextureTypeByWebGLSamplerType","samplerCubeArray","_GpuTextureViewDimensionByWebGPUTextureType","textureCube","textureCubeArray","texture2D","texture2DArray","texture3D","_SamplerTypeByWebGLSamplerType","_IsComparisonSamplerByWebGPUSamplerType","samplerShadow","samplerArrayShadow","WebGPUShaderProcessorGLSL","_missingVaryings","_textureArrayProcessing","_vertexIsGLES3","_fragmentIsGLES3","parseGLES3","startArray","indexOf","endArray","lengthInString","substring","isNaN","trim","substr","initializeShaders","processingContext","attributeKeywordName","varyingVertexKeywordName","varyingFragmentKeywordName","preProcessShaderCode","isFragment","ubDeclaration","alreadyInjected","varyingCheck","varying","test","varyingProcessor","_preProcessors","match","exec","interpolationQualifier","varyingType","attributeProcessor","attribute","attributeType","numComponents","newType","newName","uniformProcessor","arraySize","isStorageTexture","isComparisonSampler","samplerBindingType","componentType","charAt","samplerGroupIndex","samplerBindingIndex","samplerFunction","textureDimension","layouts","textureSetIndex","textureBindingIndex","uniformBufferProcessor","knownUBO","postProcessor","_processingContext","_parameters","hasDrawBuffersExtension","search","hasFragCoord","fragCoordCode","injectCode","hasOutput","lastClosingCurly","lastIndexOf","_applyTextureArrayProcessing","regex","RegExp","iindex","uniformBufferDescription","ubo","finalizeShaders","vertexCode","fragmentCode","decl","leftOverUBO","gpuTextureViewDimensionByWebGPUTextureFunction","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","texture_multisampled_2d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_external","WebGPUShaderProcessorWGSL","uniformRegexp","textureRegexp","noPrecision","preProcessor","parseFloat","_attributesInputWGSL","_attributesWGSL","_attributesConversionCodeWGSL","_hasNonFloatAttribute","_varyingsWGSL","_varyingNamesWGSL","_stridedUniformArrays","interpolationType","interpolationSampling","interpolation","textureProcessor","isArrayOfTexture","textureFunc","storageTextureFormat","isDepthTexture","definePattern","_processSamplers","_processCustomBuffers","_processStridedUniformArrays","vertexInputs","vertexOutputs","vertexMainStartingCode","vertexMainEndingCode","needDiagnosticOff","fragmentInputs","fragmentOutputs","indexLocation","number","hasFragDepth","saveIndex","builtInName_frag_depth","fragmentStartingCode","stridedArrays","stridedArrayType","samplerRegexp","suffixLessLength","part1","insertPart","part2","lastIndex","instantiateBufferRegexp","decoration","structName","bufferInfo","uniformArrayName","WebGPUSnapshotRendering","renderingMode","bundleList","_record","_play","_playBundleListIndex","_allBundleLists","_enabled","_mode","play","record","activate","_modeSaved","endRenderPass","currentRenderPass","_reportDrawCall","WebGPUStencilStateComposer","_func","funcMask","_funcMask","opStencilFail","_opStencilFail","opDepthFail","_opDepthFail","opStencilDepthPass","_opStencilDepthPass","_mask","stencilMaterialEnabled","stencilMaterial","stencilGlobal","funcRef","WebGPUTextureHelper","ComputeNumMipmapLevels","GetBlockInformationFromFormat","IsHardwareTexture","IsInternalTexture","IsImageBitmap","imageBitmap","IsImageBitmapArray","isArray","IsCompressedFormat","GetWebGPUTextureFormat","GetNumChannelsFromWebGPUTextureFormat","invertYPreMultiplyAlphaVertexSource","invertYPreMultiplyAlphaWithOfstVertexSource","PipelineType","VideoPipelineType","shadersForPipelineType","renderableTextureFormatToIndex","r8unorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8uint","rgba8sint","bgra8unorm","rgb10a2uint","rgb10a2unorm","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth32float","WebGPUTextureManager","enabledExtensions","_pipelines","_compiledShaders","_videoPipelines","_videoCompiledShaders","_deferredReleaseTextures","keys","Object","_mipmapSampler","_videoSampler","_ubCopyWithOfst","Uniform","_getPipeline","_getVideoPipeline","MipMap","params","InvertYPremultiplyAlpha","premultiplyAlpha","Clear","InvertYPremultiplyAlphaWithOfst","pipelineAndBGL","modules","processorOptions","indexParameters","shouldUseHighPrecisionShader","processor","_getShaderProcessor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","toString","platformName","shaderPlatformName","_getShaderProcessingContext","isNDCHalfZRange","migratedVertexCode","migratedFragmentCode","final","vertexModule","fragmentModule","DontInvertY","InvertY","setCommandEncoder","encoder","_commandEncoderForCreation","commandEncoder","useOwnCommandEncoder","bindGroupLayout","webgpuHardwareTexture","colorAttachments","loadOp","storeOp","passEncoder","beginRenderPass","invertYPreMultiplyAlpha","gpuOrHdwTexture","mipLevel","ofstX","ofstY","rectWidth","rectHeight","useRect","outputTexture","createTexture","_copyInvertYRenderPassDescr","_copyInvertYBindGroupWithOfst","_copyInvertYBindGroup","copyTextureToTexture","origin","depthOrArrayLayers","copyWithInvertY","srcTextureView","hasMipmaps","generateMipmaps","additionalUsages","textureSize","renderAttachmentFlag","isCompressedFormat","usages","generateCubeMipmaps","f","_mipmapGenRenderPassDescr","_mipmapGenBindGroup","_source","hasMipMaps","mipmapCount","releaseExisting","gpuMSAATexture","offsetX","offsetY","blockInformation","textureCopyView","premultipliedAlpha","textureExtent","ceil","MapWrite","copyBufferToTexture","rowsPerImage","writeTexture","dontUseRect","copyExternalImageToTexture","srcTexture","copyTextureToBuffer","releaseTexture","irradianceTexture","_irradianceTexture","destroyDeferredTextures","WebGPUTimestampQuery","_gpuFrameTimeCounter","_measureDurationState","_measureDuration","WebGPUDurationMeasure","startFrame","start","stop","timestampWrites","stopPass","duration_","querySetLabel","writeTimestamp","beginningOfPassWriteIndex","endOfPassWriteIndex","WebGPUTintWASM","initTwgsl","twgslOptions","_Twgsl","_TWgslDefaultOptions","twgsl","jsPath","wasmPath","LoadBabylonScriptAsync","self","GetBabylonScriptURL","convertSpirV2WGSL","disableUniformityAnalysis","ccode","DisableUniformityAnalysis","ShowWGSLShaderCode","_DefaultCdnUrl"],"sourceRoot":""}